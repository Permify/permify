{
  "openapi": "3.0.1",
  "info": {
    "title": "Permify API",
    "description": "Permify is an open source authorization service for creating fine-grained and scalable authorization systems.",
    "contact": {
      "name": "API Support",
      "url": "https://github.com/Permify/permify/issues",
      "email": "hello@permify.co"
    },
    "license": {
      "name": "Apache-2.0 license",
      "url": "https://github.com/Permify/permify/blob/master/LICENSE"
    },
    "version": "v1.0.3"
  },
  "servers": [
    {
      "url": "/"
    }
  ],
  "tags": [
    {
      "name": "Health"
    },
    {
      "name": "Permission"
    },
    {
      "name": "Watch"
    },
    {
      "name": "Schema"
    },
    {
      "name": "Data"
    },
    {
      "name": "Bundle"
    },
    {
      "name": "Tenancy"
    }
  ],
  "paths": {
    "/healthz": {
      "get": {
        "tags": [
          "Health"
        ],
        "summary": "health api",
        "operationId": "health.check",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "",
            "lang": "",
            "source": ""
          },
          {
            "label": "",
            "lang": "",
            "source": ""
          },
          {
            "label": "",
            "lang": "",
            "source": ""
          }
        ]
      }
    },
    "/v1/tenants/create": {
      "post": {
        "tags": [
          "Tenancy"
        ],
        "summary": "create tenant",
        "operationId": "tenants.create",
        "requestBody": {
          "description": "TenantCreateRequest is the message used for the request to create a tenant.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TenantCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TenantCreateResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "rr, err := client.Tenancy.Create(context.Background(), &v1.TenantCreateRequest{\n    Id:   \"\",\n    Name: \"\"\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.tenancy.create({\n   id: \"\",\n   name: \"\"\n}).then((response) => {\n    // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'http://localhost:3476/v1/tenants/create' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"id\": \"\",\n    \"name\": \"\"\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/list": {
      "post": {
        "tags": [
          "Tenancy"
        ],
        "summary": "list tenants",
        "operationId": "tenants.list",
        "requestBody": {
          "description": "TenantListRequest is the message used for the request to list all tenants.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TenantListRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TenantListResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "cr, err := client.Tenancy.List(context.Background(), &v1.TenantListRequest{\n    PageSize: 20,\n    ContinuousToken: \"\",\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "let res = client.tenancy.list({\n    pageSize: 20,\n    continuousToken: \"\",\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/list' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"page_size\": 20,\n    \"continuous_token\": \"\"\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{id}": {
      "delete": {
        "tags": [
          "Tenancy"
        ],
        "summary": "delete tenant",
        "operationId": "tenants.delete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "id is the unique identifier of the tenant to be deleted.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TenantDeleteResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "rr, err := client.Tenancy.Delete(context.Background(), &v1.TenantDeleteRequest{\n    Id: \"\"\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.tenancy.delete({\n   id: \"\",\n}).then((response) => {\n    // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request DELETE 'http://localhost:3476/v1/tenants/t1'"
          }
        ]
      }
    },
    "/v1/tenants/{tenant_id}/bundle/delete": {
      "post": {
        "tags": [
          "Bundle"
        ],
        "summary": "delete bundle",
        "operationId": "bundle.delete",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Bundle.DeleteBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BundleDeleteResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "rr, err := client.Bundle.Delete(context.Background(), &v1.BundleDeleteRequest{\n    TenantId: \"t1\",\n    Name:     \"organization_created\",\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.bundle.delete({\n    tenantId: \"t1\",\n    name: \"organization_created\",\n}).then((response) => {\n    // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/bundle/delete' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"name\": \"organization_created\"\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/bundle/read": {
      "post": {
        "tags": [
          "Bundle"
        ],
        "summary": "read bundle",
        "operationId": "bundle.read",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Bundle.ReadBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BundleReadResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "rr, err := client.Bundle.Read(context.Background(), &v1.BundleReadRequest{\n    TenantId: \"t1\",\n    Name:     \"organization_created\",\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.bundle.read({\n    tenantId: \"t1\",\n    name: \"organization_created\",\n}).then((response) => {\n    // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/bundle/read' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"name\": \"organization_created\"\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/bundle/write": {
      "post": {
        "tags": [
          "Bundle"
        ],
        "summary": "write bundle",
        "operationId": "bundle.write",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Bundle.WriteBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BundleWriteResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "rr, err := client.Bundle.Write(context.Background(), &v1.BundleWriteRequest{\n    TenantId: \"t1\",\n    Bundles: []*v1.DataBundle{\n        {\n            Name: \"organization_created\",\n            Arguments: []string{\n                \"creatorID\",\n                \"organizationID\",\n            },\n            Operations: []*v1.Operation{\n                {\n                    RelationshipsWrite: []string{\n                        \"organization:{{.organizationID}}#admin@user:{{.creatorID}}\",\n                        \"organization:{{.organizationID}}#manager@user:{{.creatorID}}\",\n                    },\n                    AttributesWrite: []string{\n                        \"organization:{{.organizationID}}$public|boolean:false\",\n                    },\n                },\n            },\n        },\n    },\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.bundle.write({\n    tenantId: \"t1\",\n    bundles: [\n        {\n            name: \"organization_created\",\n            arguments: [\n                \"creatorID\",\n                \"organizationID\",\n            ],\n            operations: [\n                {\n                    relationships_write: [\n                        \"organization:{{.organizationID}}#admin@user:{{.creatorID}}\",\n                        \"organization:{{.organizationID}}#manager@user:{{.creatorID}}\",\n                    ],\n                    attributes_write: [\n                        \"organization:{{.organizationID}}$public|boolean:false\",\n                    ]\n                }\n            ]\n        }\n    ]\n}).then((response) => {\n    // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/bundle/write' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"bundles\": [\n        {\n            \"name\": \"organization_created\",\n            \"arguments\": [\n                \"creatorID\",\n                \"organizationID\"\n            ],\n            \"operations\": [\n                {\n                    \"relationships_write\": [\n                        \"organization:{{.organizationID}}#admin@user:{{.creatorID}}\",\n                        \"organization:{{.organizationID}}#manager@user:{{.creatorID}}\"\n                    ],\n                    \"attributes_write\": [\n                        \"organization:{{.organizationID}}$public|boolean:false\"\n                    ]\n                }\n            ]\n        }\n    ]\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/data/attributes/read": {
      "post": {
        "tags": [
          "Data"
        ],
        "summary": "read attributes",
        "operationId": "data.attributes.read",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReadAttributesBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AttributeReadResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "rr, err := client.Data.ReadAttributes(context.Background(), &v1.Data.AttributeReadRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.Data.AttributeReadRequestMetadata{\n        SnapToken: \"\",\n    },\n    Filter: &v1.AttributeFilter{\n        Entity: &v1.EntityFilter{\n            Type: \"organization\",\n            Ids: []string{\"1\"},\n        },\n        Attributes: []string{\"private\"},\n    },\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.data.readAttributes({\n  tenantId: \"t1\",\n  metadata: {\n    snap_token: \"\",\n  },\n  filter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    attributes: [\n      \"private\"\n    ],\n  }\n}).then((response) => {\n  // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/attributes/read' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  metadata: {\n    snap_token: \"\",\n  },\n  filter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    attributes: [\n      \"private\"\n    ],\n  }\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/data/delete": {
      "post": {
        "tags": [
          "Data"
        ],
        "summary": "delete data",
        "operationId": "data.delete",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Data.DeleteBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataDeleteResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "rr, err := client.Data.Delete(context.Background(), &v1.DataDeleteRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.DataDeleteRequestMetadata{\n        SnapToken: \"\",\n    },\n    TupleFilter: &v1.TupleFilter{\n        Entity: &v1.EntityFilter{\n            Type: \"organization\",\n            Ids: []string{\"1\"},\n        },\n        Relation: \"admin\",\n        Subject: &v1.SubjectFilter{\n            Type: \"user\",\n            Id: []string{\"1\"},\n            Relation: \"\"\n        }\n    }\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.data.delete({\n  tenantId: \"t1\",\n  metadata: {\n    snap_token: \"\",\n  },\n  tupleFilter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    relation: \"admin\",\n    subject: {\n      type: \"user\",\n      ids: [\n        \"1\"\n      ],\n      relation: \"\"\n    }\n  }\n}).then((response) => {\n  // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/delete' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"tuple_filter\": {\n    \"entity\": {\n      \"type\": \"organization\",\n      \"ids\": [\n        \"1\"\n      ]\n    },\n    \"relation\": \"admin\",\n    \"subject\": {\n      \"type\": \"user\",\n      \"ids\": [\n        \"1\"\n      ],\n      \"relation\": \"\"\n    }\n  },\n  \"attribute_filter\": {}\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/data/relationships/read": {
      "post": {
        "tags": [
          "Data"
        ],
        "summary": "read relationships",
        "operationId": "data.relationships.read",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReadRelationshipsBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipReadResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "rr, err := client.Data.ReadRelationships(context.Background(), &v1.Data.RelationshipReadRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.Data.RelationshipReadRequestMetadata{\n        SnapToken: \"\"\n    },\n    Filter: &v1.TupleFilter{\n        Entity: &v1.EntityFilter{\n            Type: \"organization\",\n            Ids: []string{\"1\"},\n        },\n        Relation: \"member\",\n        Subject: &v1.SubjectFilter{\n            Type: \"\",\n            Id: []string{\"\"},\n            Relation: \"\"\n        }\n    }\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.data.readRelationships({\n  tenantId: \"t1\",\n  metadata: {\n    snap_token: \"\",\n  },\n  filter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    relation: \"member\",\n    subject: {\n      type: \"\",\n      ids: [],\n      relation: \"\"\n    }\n  }\n}).then((response) => {\n  // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/relationships/read' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  metadata: {\n    snap_token: \"\",\n  },\n  filter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    relation: \"member\",\n    subject: {\n      type: \"\",\n      ids: [],\n      relation: \"\"\n    }\n  }\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/data/run-bundle": {
      "post": {
        "tags": [
          "Data"
        ],
        "summary": "run bundle",
        "operationId": "bundle.run",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunBundleBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BundleRunResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "rr, err := client.Data.RunBundle(context.Background(), &v1.BundleRunRequest{\n    TenantId: \"t1\",\n    Name:     \"organization_created\",\n    Arguments: map[string]string{\n        \"creatorID\":      \"564\",\n        \"organizationID\": \"789\",\n    },\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.data.runBundle({\n    tenantId: \"t1\",\n    name: \"organization_created\",\n    arguments: {\n        creatorID: \"564\",\n        organizationID: \"789\",\n    }\n}).then((response) => {\n    // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/run-bundle' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"name\": \"organization_created\",\n    \"arguments\": {\n        \"creatorID\": \"564\",\n        \"organizationID\": \"789\"\n    }\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/data/write": {
      "post": {
        "tags": [
          "Data"
        ],
        "summary": "write data",
        "operationId": "data.write",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Data.WriteBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataWriteResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "// Convert the wrapped attribute value into Any proto message\nvalue, err := anypb.New(&v1.BooleanValue{\n    Data: true,\n})\nif err != nil {\n    // Handle error\n}\n\ncr, err := client.Data.Write(context.Background(), &v1.DataWriteRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.DataWriteRequestMetadata{\n        SchemaVersion: \"\",\n    },\n    Tuples: []*v1.Tuple{\n        {\n            Entity: &v1.Entity{\n                Type: \"document\",\n                Id:   \"1\",\n            },\n            Relation: \"editor\",\n            Subject:  &v1.Subject{\n                Type: \"user\",\n                Id:   \"1\",\n                Relation: \"\",\n            },\n        },\n    },\n    Attributes: []*v1.Attribute{\n        {\n            Entity: &v1.Entity{\n                Type: \"document\",\n                Id:   \"1\",\n            },\n            Attribute: \"is_private\",\n            Value:     value,\n        },\n    },\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "const booleanValue = BooleanValue.fromJSON({ data: true });\n\nconst value = Any.fromJSON({\n    typeUrl: 'type.googleapis.com/base.v1.BooleanValue',\n    value: BooleanValue.encode(booleanValue).finish()\n});\n\nclient.data.write({\n    tenantId: \"t1\",\n    metadata: {\n        schemaVersion: \"\"\n    },\n    tuples: [{\n        entity: {\n            type: \"document\",\n            id: \"1\"\n        },\n        relation: \"editor\",\n        subject: {\n            type: \"user\",\n            id: \"1\"\n        }\n    }],\n    attributes: [{\n        entity: {\n            type: \"document\",\n            id: \"1\"\n        },\n        attribute: \"is_private\",\n        value: value,\n    }]\n}).then((response) => {\n    // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/write' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"metadata\": {\n        \"schema_version\": \"\"\n    },\n    \"tuples\": [\n        {\n            \"entity\": {\n                \"type\": \"document\",\n                \"id\": \"1\"\n            },\n            \"relation\": \"editor\",\n            \"subject\": {\n                \"type\": \"user\",\n                \"id\": \"1\"\n            }\n        }\n    ],\n    \"attributes\": [\n        {\n            \"entity\": {\n                \"type\": \"document\",\n                \"id\": \"1\"\n            },\n            \"attribute\": \"is_private\",\n            \"value\": {\n                \"@type\": \"type.googleapis.com/base.v1.BooleanValue\",\n                \"data\": true\n            }\n        }\n    ]\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/permissions/check": {
      "post": {
        "tags": [
          "Permission"
        ],
        "summary": "check api",
        "operationId": "permissions.check",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Permission.CheckBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PermissionCheckResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "cr, err := client.Permission.Check(context.Background(), &v1.PermissionCheckRequest {\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionCheckRequestMetadata {\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        Depth: 20,\n    },\n    Entity: &v1.Entity {\n        Type: \"repository\",\n        Id: \"1\",\n    },\n    Permission: \"edit\",\n    Subject: &v1.Subject {\n        Type: \"user\",\n        Id: \"1\",\n    },\n})\nif cr.Can == v1.PermissionCheckResponse_Result_RESULT_ALLOWED {\n    // RESULT_ALLOWED\n} else {\n    // RESULT_DENIED\n}"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.permission.check({\n    tenantId: \"t1\", \n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\",\n        depth: 20\n    },\n    entity: {\n        type: \"repository\",\n        id: \"1\"\n    },\n    permission: \"edit\",\n    subject: {\n        type: \"user\",\n        id: \"1\"\n    }\n}).then((response) => {\n    if (response.can === PermissionCheckResponse_Result.RESULT_ALLOWED) {\n        console.log(\"RESULT_ALLOWED\")\n    } else {\n        console.log(\"RESULT_DENIED\")\n    }\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/check' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\": {\n    \"snap_token\": \"\",\n    \"schema_version\": \"\",\n    \"depth\": 20\n  },\n  \"entity\": {\n    \"type\": \"repository\",\n    \"id\": \"1\"\n  },\n  \"permission\": \"edit\",\n  \"subject\": {\n    \"type\": \"user\",\n    \"id\": \"1\",\n    \"relation\": \"\"\n  }\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/permissions/expand": {
      "post": {
        "tags": [
          "Permission"
        ],
        "summary": "expand api",
        "operationId": "permissions.expand",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Permission.ExpandBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PermissionExpandResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "cr, err := client.Permission.Expand(context.Background(), &v1.PermissionExpandRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionExpandRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n    },\n    Entity: &v1.Entity{\n        Type: \"repository\",\n        Id: \"1\",\n    },\n    Permission: \"push\",\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.permission.expand({\n    tenantId: \"t1\",\n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\"\n    },\n    entity: {\n        type: \"repository\",\n        id: \"1\"\n    },\n    permission: \"push\",\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/expand' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\": {\n    \"schema_version\": \"\",\n    \"snap_token\": \"\"\n  },\n  \"entity\": {\n    \"type\": \"repository\",\n    \"id\": \"1\"\n  },\n  \"permission\": \"push\"\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/permissions/lookup-entity": {
      "post": {
        "tags": [
          "Permission"
        ],
        "summary": "lookup entity",
        "operationId": "permissions.lookupEntity",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LookupEntityBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PermissionLookupEntityResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "cr, err := client.Permission.LookupEntity(context.Background(), &v1.PermissionLookupEntityRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionLookupEntityRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        Depth: 20,\n    },\n    EntityType: \"document\",\n    Permission: \"edit\",\n    Subject: &v1.Subject{\n        Type: \"user\",\n        Id: \"1\",\n    }\n    PageSize: 20,\n    ContinuousToken: \"\",\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.permission.lookupEntity({\n    tenantId: \"t1\",\n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\",\n        depth: 20\n    },\n    entity_type: \"document\",\n    permission: \"edit\",\n    subject: {\n        type: \"user\",\n        id: \"1\"\n    },\n    page_size: 20,\n    continuous_token: \"\"\n}).then((response) => {\n    console.log(response.entity_ids)\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/lookup-entity' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\":{\n    \"snap_token\": \"\",\n    \"schema_version\": \"\",\n    \"depth\": 20\n  },\n  \"entity_type\": \"document\",\n  \"permission\": \"edit\",\n  \"subject\": {\n    \"type\":\"user\",\n    \"id\":\"1\"\n  },\n  \"page_size\": 20,\n  \"continuous_token\": \"\",\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/permissions/lookup-entity-stream": {
      "post": {
        "tags": [
          "Permission"
        ],
        "summary": "lookup entity stream",
        "operationId": "permissions.lookupEntityStream",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LookupEntityStreamBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Stream result of PermissionLookupEntityStreamResponse",
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/PermissionLookupEntityStreamResponse"
                    },
                    "error": {
                      "$ref": "#/components/schemas/Status"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "str, err := client.Permission.LookupEntityStream(context.Background(), &v1.PermissionLookupEntityRequest{\n    Metadata: &v1.PermissionLookupEntityRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        Depth: 50,\n    },\n    EntityType: \"document\",\n    Permission: \"view\",\n    Subject: &v1.Subject{\n        Type: \"user\",\n        Id: \"1\",\n    },\n    PageSize: 20,\n    ContinuousToken: \"\",\n})\n\n// handle stream response\nfor {\n    res, err := str.Recv()\n\n    if err == io.EOF {\n        break\n    }\n\n    // res.EntityId\n}"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "const permify = require(\"@permify/permify-node\");\nconst {PermissionLookupEntityStreamResponse} = require(\"@permify/permify-node/dist/src/grpc/generated/base/v1/service\");\n\nfunction main() {\n    const client = new permify.grpc.newClient({\n        endpoint: \"localhost:3478\",\n    });\n\n    let res = client.permission.lookupEntityStream({\n        metadata: {\n            snapToken: \"\",\n            schemaVersion: \"\",\n            depth: 20\n        },\n        entityType: \"document\",\n        permission: \"view\",\n        subject: {\n            type: \"user\",\n            id: \"1\"\n        },\n        page_size: 20,\n        continuous_token: \"\"\n    });\n\n    handle(res);\n}\n\nasync function handle(res: AsyncIterable<PermissionLookupEntityStreamResponse>) {\n    for await (const response of res) {\n        // response.entityId\n    }\n}"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/permissions/lookup-subject": {
      "post": {
        "tags": [
          "Permission"
        ],
        "summary": "lookup-subject",
        "operationId": "permissions.lookupSubject",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LookupSubjectBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PermissionLookupSubjectResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "cr, err := client.Permission.LookupSubject(context.Background(), &v1.PermissionLookupSubjectRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionLookupSubjectRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        Depth: 20,\n    },\n    Entity: &v1.Entity{\n        Type: \"document\",\n        Id: \"1\",\n    },\n    Permission: \"edit\",\n    SubjectReference: &v1.RelationReference{\n        Type: \"user\",\n        Relation: \"\",\n    },\n    PageSize: 20,\n    ContinuousToken: \"\",\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.permission.lookupSubject({\n    tenantId: \"t1\",\n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\",\n        depth: 20,\n    },\n    entity: {\n        type: \"document\",\n        id: \"1\",\n    },\n    permission: \"edit\",\n    subject_reference: {\n        type: \"user\",\n        relation: \"\"\n    },\n    page_size: 10,\n    continuous_token: \"\"\n}).then((response) => {\n    console.log(response.subject_ids)\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/lookup-subject' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\":{\n    \"snap_token\": \"\",\n    \"schema_version\": \"\",\n    \"depth\": 20,\n  },\n  \"entity\": {\n    \"type\": \"document\",\n    \"id\": \"1\"\n  },\n  \"permission\": \"edit\",\n  \"subject_reference\": {\n    \"type\": \"user\",\n    \"relation\": \"\"\n  },\n   page_size: 20,\n   continuous_token: \"\"\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/permissions/subject-permission": {
      "post": {
        "tags": [
          "Permission"
        ],
        "summary": "subject permission",
        "operationId": "permissions.subjectPermission",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubjectPermissionBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PermissionSubjectPermissionResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "cr, err := client.Permission.SubjectPermission(context.Background(), &v1.PermissionSubjectPermissionRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionSubjectPermissionRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        OnlyPermission: false,\n        Depth: 20,\n    },\n    Entity: &v1.Entity{\n        Type: \"repository\",\n        Id: \"1\",\n    },\n    Subject: &v1.Subject{\n        Type: \"user\",\n        Id: \"1\",\n    },\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.permission.subjectPermission({\n    tenantId: \"t1\",\n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\",\n        onlyPermission: true,\n        depth: 20\n    },\n    entity: {\n        type: \"repository\",\n        id: \"1\"\n    },\n    subject: {\n        type: \"user\",\n        id: \"1\"\n    }\n}).then((response) => {\n    console.log(response);\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/subject-permission' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\":{\n    \"snap_token\": \"\",\n    \"schema_version\": \"\",\n    \"only_permission\": true,\n    \"depth\": 20\n  },\n  \"entity\": {\n    \"type\": \"repository\",\n    \"id\": \"1\"\n  },\n  \"subject\": {\n    \"type\": \"user\",\n    \"id\": \"1\",\n    \"relation\": \"\"\n  }\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/relationships/delete": {
      "post": {
        "tags": [
          "Data"
        ],
        "summary": "delete relationships",
        "operationId": "relationships.delete",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteRelationshipsBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipDeleteResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/relationships/write": {
      "post": {
        "tags": [
          "Data"
        ],
        "summary": "write relationships",
        "operationId": "relationships.write",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteRelationshipsBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipWriteResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/schemas/list": {
      "post": {
        "tags": [
          "Schema"
        ],
        "summary": "list schema",
        "operationId": "schemas.list",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Schema.ListBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaListResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "sr, err := client.Schema.List(context.Background(), &v1.SchemaListRequest{\n    TenantId: \"t1\",\n    PageSize: 20,\n    ContinuousToken: \"\",\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "let res = client.schema.list({\n    tenantId: \"t1\",\n    continuousToken: \"\"\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/schemas/list' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"page_size\": 20,\n    \"continuous_token\": \"\"\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/schemas/partial-write": {
      "patch": {
        "tags": [
          "Schema"
        ],
        "summary": "partially update your authorization model",
        "operationId": "schemas.partial-write",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "tenant_id is a string that identifies the tenant. It must match the pattern \"[a-zA-Z0-9-,]+\",\nbe a maximum of 64 bytes, and must not be empty.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PartialWriteBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaPartialWriteResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/schemas/read": {
      "post": {
        "tags": [
          "Schema"
        ],
        "summary": "read schema",
        "operationId": "schemas.read",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Schema.ReadBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaReadResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "sr, err := client.Schema.Read(context.Background(), &v1.SchemaReadRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.SchemaReadRequestMetadata{\n        SchemaVersion: \"cnbe6se5fmal18gpc66g\",\n    },\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "let res = client.schema.read({\n    tenantId: \"t1\",\n    metadata: {\n        schemaVersion: swResponse.schemaVersion,\n    },\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/schemas/read' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"metadata\": {\n        \"schema_version\": \"cnbe6se5fmal18gpc66g\"\n    }\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/schemas/write": {
      "post": {
        "tags": [
          "Schema"
        ],
        "summary": "write schema",
        "operationId": "schemas.write",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Schema.WriteBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaWriteResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "sr, err := client.Schema.Write(context.Background(), &v1.SchemaWriteRequest{\n    TenantId: \"t1\",\n    Schema: `\n    entity user {}\n\n    entity organization {\n        relation admin @user\n        relation member @user\n\n        action create_repository = (admin or member)\n        action delete = admin\n    }\n\n    entity repository {\n        relation owner @user\n        relation parent @organization\n\n        action push = owner\n        action read = (owner and (parent.admin and parent.member))\n        action delete = (parent.member and (parent.admin or owner))\n    }\n    `,\n})"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "client.schema.write({\n    tenantId: \"t1\",\n    schema: `\n    entity user {}\n\n    entity organization {\n        relation admin @user\n        relation member @user\n\n        action create_repository = (admin or member)\n        action delete = admin\n    }\n\n    entity repository {\n        relation owner @user\n        relation parent @organization\n\n        action push = owner\n        action read = (owner and (parent.admin and parent.member))\n        action delete = (parent.member and (parent.admin or owner))\n    }\n    `\n}).then((response) => {\n    // handle response\n})"
          },
          {
            "label": "cURL",
            "lang": "curl",
            "source": "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/schemas/write' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"schema\": \"entity user {}\\n\\n    entity organization {\\n\\n        relation admin @user\\n        relation member @user\\n\\n        action create_repository = (admin or member)\\n        action delete = admin\\n    }\\n\\n    entity repository {\\n\\n        relation owner @user\\n        relation parent @organization\\n\\n        action push = owner\\n        action read = (owner and (parent.admin and parent.member))\\n        action delete = (parent.member and (parent.admin or owner))\\n }\"\n}'"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/tenants/{tenant_id}/watch": {
      "post": {
        "tags": [
          "Watch"
        ],
        "summary": "watch changes",
        "operationId": "watch.watch",
        "parameters": [
          {
            "name": "tenant_id",
            "in": "path",
            "description": "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WatchBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Stream result of WatchResponse",
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/WatchResponse"
                    },
                    "error": {
                      "$ref": "#/components/schemas/Status"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "label": "go",
            "lang": "go",
            "source": "cr, err := client.Watch.Watch(context.Background(), &v1.WatchRequest{\n    TenantId:  \"t1\",\n    SnapToken: \"\",\n})\n// handle stream response\nfor {\n    res, err := cr.Recv()\n\n    if err == io.EOF {\n        break\n    }\n\n    // res.Changes\n}\n"
          },
          {
            "label": "node",
            "lang": "javascript",
            "source": "const permify = require(\"@permify/permify-node\");\nconst {WatchResponse} = require(\"@permify/permify-node/dist/src/grpc/generated/base/v1/service\");\n\nfunction main() {\n    const client = new permify.grpc.newClient({\n        endpoint: \"localhost:3478\",\n    });\n\n    let res = client.watch.watch({\n        tenantId: \"t1\",\n        snapToken: \"\"\n    });\n\n    handle(res);\n}\n\nasync function handle(res: AsyncIterable<WatchResponse>) {\n    for await (const response of res) {\n        // response.changes\n    }\n}\n"
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    }
  },
  "components": {
    "schemas": {
      "AbstractType": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The fully qualified name of this abstract type."
          },
          "parameterTypes": {
            "type": "array",
            "description": "Parameter types for this abstract type.",
            "items": {
              "$ref": "#/components/schemas/v1alpha1.Type"
            }
          }
        },
        "description": "Application defined abstract type."
      },
      "Any": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
          }
        },
        "additionalProperties": {
          "type": "object"
        },
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
      },
      "Argument": {
        "type": "object",
        "properties": {
          "computedAttribute": {
            "$ref": "#/components/schemas/ComputedAttribute"
          },
          "contextAttribute": {
            "$ref": "#/components/schemas/ContextAttribute"
          }
        },
        "description": "Argument defines the type of argument in a Call. It can be either a ComputedAttribute or a ContextAttribute."
      },
      "Attribute": {
        "type": "object",
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/Entity"
          },
          "attribute": {
            "title": "Name of the attribute",
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/Any"
          }
        },
        "description": "Attribute represents an attribute of an entity with a specific type and value."
      },
      "AttributeDefinition": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the attribute, which follows a specific string pattern and has a maximum byte size."
          },
          "type": {
            "$ref": "#/components/schemas/AttributeType"
          }
        },
        "description": "The AttributeDefinition message provides detailed information about a specific attribute."
      },
      "AttributeFilter": {
        "type": "object",
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/EntityFilter"
          },
          "attributes": {
            "title": "Names of the attributes to be filtered",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "AttributeFilter is used to filter attributes based on the entity and attribute names."
      },
      "AttributeReadRequestMetadata": {
        "type": "object",
        "properties": {
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)"
          }
        },
        "description": "AttributeReadRequestMetadata defines the structure for the metadata of an attribute read request.\nIt includes the snap_token associated with a particular state of the database."
      },
      "AttributeReadResponse": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "array",
            "description": "attributes is a list of the attributes retrieved in the read operation.",
            "items": {
              "$ref": "#/components/schemas/Attribute"
            }
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is used in the case of paginated reads to retrieve the next page of results."
          }
        },
        "description": "AttributeReadResponse defines the structure of the response to an attribute read request.\nIt includes the attributes retrieved and a continuous token for handling result pagination."
      },
      "AttributeType": {
        "type": "string",
        "description": "Enumerates the types of attribute.\n\n - ATTRIBUTE_TYPE_UNSPECIFIED: Not specified attribute type. This is the default value.\n - ATTRIBUTE_TYPE_BOOLEAN: A boolean attribute type.\n - ATTRIBUTE_TYPE_BOOLEAN_ARRAY: A boolean array attribute type.\n - ATTRIBUTE_TYPE_STRING: A string attribute type.\n - ATTRIBUTE_TYPE_STRING_ARRAY: A string array attribute type.\n - ATTRIBUTE_TYPE_INTEGER: An integer attribute type.\n - ATTRIBUTE_TYPE_INTEGER_ARRAY: An integer array attribute type.\n - ATTRIBUTE_TYPE_DOUBLE: A double attribute type.\n - ATTRIBUTE_TYPE_DOUBLE_ARRAY: A double array attribute type.",
        "default": "ATTRIBUTE_TYPE_UNSPECIFIED",
        "enum": [
          "ATTRIBUTE_TYPE_UNSPECIFIED",
          "ATTRIBUTE_TYPE_BOOLEAN",
          "ATTRIBUTE_TYPE_BOOLEAN_ARRAY",
          "ATTRIBUTE_TYPE_STRING",
          "ATTRIBUTE_TYPE_STRING_ARRAY",
          "ATTRIBUTE_TYPE_INTEGER",
          "ATTRIBUTE_TYPE_INTEGER_ARRAY",
          "ATTRIBUTE_TYPE_DOUBLE",
          "ATTRIBUTE_TYPE_DOUBLE_ARRAY"
        ]
      },
      "Bundle.DeleteBody": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the bundle to be deleted."
          }
        },
        "description": "BundleDeleteRequest is used to request the deletion of a bundle.\nIt contains the tenant_id to specify the tenant and the name of the bundle to be deleted."
      },
      "Bundle.ReadBody": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "Bundle.WriteBody": {
        "type": "object",
        "properties": {
          "bundles": {
            "type": "array",
            "description": "Contains the bundle data to be written.",
            "items": {
              "$ref": "#/components/schemas/DataBundle"
            }
          }
        },
        "description": "BundleWriteRequest is used to request the writing of a bundle.\nIt contains the tenant_id to identify the tenant and the Bundles object."
      },
      "BundleDeleteResponse": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "BundleReadResponse": {
        "type": "object",
        "properties": {
          "bundle": {
            "$ref": "#/components/schemas/DataBundle"
          }
        }
      },
      "BundleRunResponse": {
        "type": "object",
        "properties": {
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)"
          }
        },
        "description": "BundleRunResponse is the response for a BundleRunRequest.\nIt includes a snap_token, which may be used for tracking the execution or its results."
      },
      "BundleWriteResponse": {
        "type": "object",
        "properties": {
          "names": {
            "type": "array",
            "description": "Identifier or acknowledgment of the written bundle.",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "BundleWriteResponse is the response for a BundleWriteRequest.\nIt includes a name which could be used as an identifier or acknowledgment."
      },
      "CheckResult": {
        "type": "string",
        "description": "Enumerates results of a check operation.\n\n - CHECK_RESULT_UNSPECIFIED: Not specified check result. This is the default value.\n - CHECK_RESULT_ALLOWED: Represents a successful check (the check allowed the operation).\n - CHECK_RESULT_DENIED: Represents a failed check (the check denied the operation).",
        "default": "CHECK_RESULT_UNSPECIFIED",
        "enum": [
          "CHECK_RESULT_UNSPECIFIED",
          "CHECK_RESULT_ALLOWED",
          "CHECK_RESULT_DENIED"
        ]
      },
      "CheckedExpr": {
        "type": "object",
        "properties": {
          "referenceMap": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/v1alpha1.Reference"
            },
            "description": "A map from expression ids to resolved references.\n\nThe following entries are in this table:\n\n- An Ident or Select expression is represented here if it resolves to a\n  declaration. For instance, if `a.b.c` is represented by\n  `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,\n  while `c` is a field selection, then the reference is attached to the\n  nested select expression (but not to the id or or the outer select).\n  In turn, if `a` resolves to a declaration and `b.c` are field selections,\n  the reference is attached to the ident expression.\n- Every Call expression has an entry here, identifying the function being\n  called.\n- Every CreateStruct expression for a message has an entry, identifying\n  the message."
          },
          "typeMap": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/v1alpha1.Type"
            },
            "description": "A map from expression ids to types.\n\nEvery expression node which has a type different than DYN has a mapping\nhere. If an expression has type DYN, it is omitted from this map to save\nspace."
          },
          "sourceInfo": {
            "$ref": "#/components/schemas/SourceInfo"
          },
          "exprVersion": {
            "type": "string",
            "description": "The expr version indicates the major / minor version number of the `expr`\nrepresentation.\n\nThe most common reason for a version change will be to indicate to the CEL\nruntimes that transformations have been performed on the expr during static\nanalysis. In some cases, this will save the runtime the work of applying\nthe same or similar transformations prior to evaluation."
          },
          "expr": {
            "$ref": "#/components/schemas/Expr"
          }
        },
        "description": "A CEL expression which has been successfully type checked."
      },
      "Child": {
        "type": "object",
        "properties": {
          "leaf": {
            "$ref": "#/components/schemas/Leaf"
          },
          "rewrite": {
            "$ref": "#/components/schemas/Rewrite"
          }
        },
        "description": "Child represents a node in the permission tree."
      },
      "Comprehension": {
        "type": "object",
        "properties": {
          "iterVar": {
            "type": "string",
            "description": "The name of the iteration variable."
          },
          "iterRange": {
            "$ref": "#/components/schemas/Expr"
          },
          "accuVar": {
            "type": "string",
            "description": "The name of the variable used for accumulation of the result."
          },
          "accuInit": {
            "$ref": "#/components/schemas/Expr"
          },
          "loopCondition": {
            "$ref": "#/components/schemas/Expr"
          },
          "loopStep": {
            "$ref": "#/components/schemas/Expr"
          },
          "result": {
            "$ref": "#/components/schemas/Expr"
          }
        },
        "description": "A comprehension expression applied to a list or map.\n\nComprehensions are not part of the core syntax, but enabled with macros.\nA macro matches a specific call signature within a parsed AST and replaces\nthe call with an alternate AST block. Macro expansion happens at parse\ntime.\n\nThe following macros are supported within CEL:\n\nAggregate type macros may be applied to all elements in a list or all keys\nin a map:\n\n*  `all`, `exists`, `exists_one` -  test a predicate expression against\n   the inputs and return `true` if the predicate is satisfied for all,\n   any, or only one value `list.all(x, x < 10)`.\n*  `filter` - test a predicate expression against the inputs and return\n   the subset of elements which satisfy the predicate:\n   `payments.filter(p, p > 1000)`.\n*  `map` - apply an expression to all elements in the input and return the\n   output aggregate type: `[1, 2, 3].map(i, i * i)`.\n\nThe `has(m.x)` macro tests whether the property `x` is present in struct\n`m`. The semantics of this macro depend on the type of `m`. For proto2\nmessages `has(m.x)` is defined as 'defined, but not set`. For proto3, the\nmacro tests whether the property is set to its default. For map and struct\ntypes, the macro tests whether the property `x` is defined on `m`."
      },
      "ComputedAttribute": {
        "type": "object",
        "properties": {
          "name": {
            "title": "Name of the computed attribute",
            "type": "string"
          }
        },
        "description": "ComputedAttribute defines a computed attribute which includes its name."
      },
      "ComputedUserSet": {
        "type": "object",
        "properties": {
          "relation": {
            "title": "Relation name",
            "type": "string"
          }
        },
        "description": "ComputedUserSet defines a set of computed users which includes the relation name."
      },
      "Constant": {
        "type": "object",
        "properties": {
          "nullValue": {
            "type": "string",
            "description": "null value."
          },
          "boolValue": {
            "type": "boolean",
            "description": "boolean value."
          },
          "int64Value": {
            "type": "string",
            "description": "int64 value.",
            "format": "int64"
          },
          "uint64Value": {
            "type": "string",
            "description": "uint64 value.",
            "format": "uint64"
          },
          "doubleValue": {
            "type": "number",
            "description": "double value.",
            "format": "double"
          },
          "stringValue": {
            "type": "string",
            "description": "string value."
          },
          "bytesValue": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "bytes value.",
            "format": "byte"
          },
          "durationValue": {
            "type": "string",
            "description": "protobuf.Duration value.\n\nDeprecated: duration is no longer considered a builtin cel type."
          },
          "timestampValue": {
            "type": "string",
            "description": "protobuf.Timestamp value.\n\nDeprecated: timestamp is no longer considered a builtin cel type.",
            "format": "date-time"
          }
        },
        "description": "Represents a primitive literal.\n\nNamed 'Constant' here for backwards compatibility.\n\nThis is similar as the primitives supported in the well-known type\n`google.protobuf.Value`, but richer so it can represent CEL's full range of\nprimitives.\n\nLists and structs are not included as constants as these aggregate types may\ncontain [Expr][google.api.expr.v1alpha1.Expr] elements which require evaluation and are thus not constant.\n\nExamples of literals include: `\"hello\"`, `b'bytes'`, `1u`, `4.2`, `-2`,\n`true`, `null`."
      },
      "Context": {
        "type": "object",
        "properties": {
          "tuples": {
            "type": "array",
            "description": "A repeated field of tuples involved in the operation.",
            "items": {
              "$ref": "#/components/schemas/Tuple"
            }
          },
          "attributes": {
            "type": "array",
            "description": "A repeated field of attributes associated with the operation.",
            "items": {
              "$ref": "#/components/schemas/Attribute"
            }
          },
          "data": {
            "type": "object",
            "properties": {},
            "description": "Additional data associated with the context."
          }
        },
        "description": "Context encapsulates the information related to a single operation,\nincluding the tuples involved and the associated attributes."
      },
      "ContextAttribute": {
        "type": "object",
        "properties": {
          "name": {
            "title": "Name of the context attribute",
            "type": "string"
          }
        },
        "description": "ContextAttribute defines a context attribute which includes its name."
      },
      "CreateList": {
        "type": "object",
        "properties": {
          "elements": {
            "type": "array",
            "description": "The elements part of the list.",
            "items": {
              "$ref": "#/components/schemas/Expr"
            }
          },
          "optionalIndices": {
            "type": "array",
            "description": "The indices within the elements list which are marked as optional\nelements.\n\nWhen an optional-typed value is present, the value it contains\nis included in the list. If the optional-typed value is absent, the list\nelement is omitted from the CreateList result.",
            "items": {
              "type": "integer",
              "format": "int32"
            }
          }
        },
        "description": "A list creation expression.\n\nLists may either be homogenous, e.g. `[1, 2, 3]`, or heterogeneous, e.g.\n`dyn([1, 'hello', 2.0])`"
      },
      "CreateStruct": {
        "type": "object",
        "properties": {
          "messageName": {
            "type": "string",
            "description": "The type name of the message to be created, empty when creating map\nliterals."
          },
          "entries": {
            "type": "array",
            "description": "The entries in the creation expression.",
            "items": {
              "$ref": "#/components/schemas/Entry"
            }
          }
        },
        "description": "A map or message creation expression.\n\nMaps are constructed as `{'key_name': 'value'}`. Message construction is\nsimilar, but prefixed with a type name and composed of field ids:\n`types.MyType{field_id: 'value'}`."
      },
      "Data.DeleteBody": {
        "type": "object",
        "properties": {
          "tuple_filter": {
            "$ref": "#/components/schemas/TupleFilter"
          },
          "attribute_filter": {
            "$ref": "#/components/schemas/AttributeFilter"
          }
        },
        "description": "DataDeleteRequest defines the structure of a request to delete data.\nIt includes the tenant_id and filters for selecting tuples and attributes to be deleted."
      },
      "Data.WriteBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/DataWriteRequestMetadata"
          },
          "tuples": {
            "type": "array",
            "description": "tuples contains the list of tuples (entity-relation-entity triples) that need to be written.",
            "items": {
              "$ref": "#/components/schemas/Tuple"
            }
          },
          "attributes": {
            "type": "array",
            "description": "attributes contains the list of attributes (entity-attribute-value triples) that need to be written.",
            "items": {
              "$ref": "#/components/schemas/Attribute"
            }
          }
        },
        "description": "DataWriteRequest defines the structure of a request for writing data.\nIt contains the necessary information such as tenant_id, metadata,\ntuples and attributes for the write operation."
      },
      "DataBundle": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "'name' is a simple string field representing the name of the DataBundle."
          },
          "arguments": {
            "type": "array",
            "description": "'arguments' is a repeated field, which means it can contain multiple strings.\nThese are used to store a list of arguments related to the DataBundle.",
            "items": {
              "type": "string"
            }
          },
          "operations": {
            "type": "array",
            "description": "'operations' is a repeated field containing multiple Operation messages.\nEach Operation represents a specific action or set of actions to be performed.",
            "items": {
              "$ref": "#/components/schemas/v1.Operation"
            }
          }
        },
        "description": "DataBundle is a message representing a bundle of data, which includes a name,\na list of arguments, and a series of operations."
      },
      "DataChange": {
        "type": "object",
        "properties": {
          "operation": {
            "$ref": "#/components/schemas/DataChange.Operation"
          },
          "tuple": {
            "$ref": "#/components/schemas/Tuple"
          },
          "attribute": {
            "$ref": "#/components/schemas/Attribute"
          }
        },
        "description": "DataChange represents a single change in data, with an operation type and the actual change which could be a tuple or an attribute."
      },
      "DataChange.Operation": {
        "type": "string",
        "description": " - OPERATION_UNSPECIFIED: Default operation, not specified.\n - OPERATION_CREATE: Creation operation.\n - OPERATION_DELETE: Deletion operation.",
        "default": "OPERATION_UNSPECIFIED",
        "enum": [
          "OPERATION_UNSPECIFIED",
          "OPERATION_CREATE",
          "OPERATION_DELETE"
        ]
      },
      "DataChanges": {
        "type": "object",
        "properties": {
          "snap_token": {
            "type": "string",
            "description": "The snapshot token."
          },
          "data_changes": {
            "type": "array",
            "description": "The list of data changes.",
            "items": {
              "$ref": "#/components/schemas/DataChange"
            }
          }
        },
        "description": "DataChanges represent changes in data with a snap token and a list of data change objects."
      },
      "DataDeleteResponse": {
        "type": "object",
        "properties": {
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)"
          }
        },
        "description": "DataDeleteResponse defines the structure of the response to a data delete request.\nIt includes a snap_token representing the state of the database after the deletion."
      },
      "DataWriteRequestMetadata": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "schema_version represents the version of the schema for the data being written."
          }
        },
        "description": "DataWriteRequestMetadata defines the structure of metadata for a write request.\nIt includes the schema version of the data to be written."
      },
      "DataWriteResponse": {
        "type": "object",
        "properties": {
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)."
          }
        },
        "description": "DataWriteResponse defines the structure of the response after writing data.\nIt contains the snap_token generated after the write operation."
      },
      "DeleteRelationshipsBody": {
        "title": "RelationshipDeleteRequest",
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/TupleFilter"
          }
        }
      },
      "Entity": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "id": {
            "type": "string"
          }
        },
        "description": "Entity represents an entity with a type and an identifier."
      },
      "EntityDefinition": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the entity, which follows a specific string pattern and has a maximum byte size."
          },
          "relations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/RelationDefinition"
            },
            "description": "Map of relation definitions within this entity. The key is the relation name, and the value is the RelationDefinition."
          },
          "permissions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PermissionDefinition"
            },
            "description": "Map of permission definitions within this entity. The key is the permission name, and the value is the PermissionDefinition."
          },
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/AttributeDefinition"
            },
            "description": "Map of attribute definitions within this entity. The key is the attribute name, and the value is the AttributeDefinition."
          },
          "references": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/EntityDefinition.Reference"
            },
            "description": "Map of references indicating whether a string pertains to a relation, permission, or attribute."
          }
        },
        "description": "The EntityDefinition message provides detailed information about a specific entity."
      },
      "EntityDefinition.Reference": {
        "type": "string",
        "description": "The Reference enum specifies whether a name pertains to a relation, permission, or attribute.\n\n - REFERENCE_UNSPECIFIED: Default, unspecified reference.\n - REFERENCE_RELATION: Indicates that the name refers to a relation.\n - REFERENCE_PERMISSION: Indicates that the name refers to a permission.\n - REFERENCE_ATTRIBUTE: Indicates that the name refers to an attribute.",
        "default": "REFERENCE_UNSPECIFIED",
        "enum": [
          "REFERENCE_UNSPECIFIED",
          "REFERENCE_RELATION",
          "REFERENCE_PERMISSION",
          "REFERENCE_ATTRIBUTE"
        ]
      },
      "EntityFilter": {
        "type": "object",
        "properties": {
          "type": {
            "title": "Type of the entity",
            "type": "string"
          },
          "ids": {
            "title": "List of entity IDs",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "EntityFilter is used to filter entities based on the type and ids."
      },
      "Entry": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Required. An id assigned to this node by the parser which is unique\nin a given expression tree. This is used to associate type\ninformation and other attributes to the node.",
            "format": "int64"
          },
          "fieldKey": {
            "type": "string",
            "description": "The field key for a message creator statement."
          },
          "mapKey": {
            "$ref": "#/components/schemas/Expr"
          },
          "value": {
            "$ref": "#/components/schemas/Expr"
          },
          "optionalEntry": {
            "type": "boolean",
            "description": "Whether the key-value pair is optional."
          }
        },
        "description": "Represents an entry."
      },
      "ExpandLeaf": {
        "type": "object",
        "properties": {
          "subjects": {
            "$ref": "#/components/schemas/Subjects"
          },
          "values": {
            "$ref": "#/components/schemas/Values"
          },
          "value": {
            "$ref": "#/components/schemas/Any"
          }
        },
        "description": "ExpandLeaf is the leaf node of an Expand tree and can be either a set of Subjects or a set of Values."
      },
      "ExpandTreeNode": {
        "type": "object",
        "properties": {
          "operation": {
            "$ref": "#/components/schemas/ExpandTreeNode.Operation"
          },
          "children": {
            "title": "The children of this tree node",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1.Expand"
            }
          }
        },
        "description": "ExpandTreeNode represents a node in an expansion tree with a specific operation and its children."
      },
      "ExpandTreeNode.Operation": {
        "type": "string",
        "description": "Operation is an enum representing the type of operation to be applied on the tree node.",
        "default": "OPERATION_UNSPECIFIED",
        "enum": [
          "OPERATION_UNSPECIFIED",
          "OPERATION_UNION",
          "OPERATION_INTERSECTION",
          "OPERATION_EXCLUSION"
        ]
      },
      "Expr": {
        "type": "object",
        "description": "An abstract representation of a common expression.\n\nExpressions are abstractly represented as a collection of identifiers,\nselect statements, function calls, literals, and comprehensions. All\noperators with the exception of the '.' operator are modelled as function\ncalls. This makes it easy to represent new operators into the existing AST.\n\nAll references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at\ntype-check for an expression to be valid. A reference may either be a bare\nidentifier `name` or a qualified identifier `google.api.name`. References\nmay either refer to a value or a function declaration.\n\nFor example, the expression `google.api.name.startsWith('expr')` references\nthe declaration `google.api.name` within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and\nthe function declaration `startsWith`."
      },
      "Expr.Call": {
        "type": "object",
        "properties": {
          "target": {
            "$ref": "#/components/schemas/Expr"
          },
          "function": {
            "type": "string",
            "description": "Required. The name of the function or method being called."
          },
          "args": {
            "type": "array",
            "description": "The arguments.",
            "items": {
              "$ref": "#/components/schemas/Expr"
            }
          }
        },
        "description": "A call expression, including calls to predefined functions and operators.\n\nFor example, `value == 10`, `size(map_value)`."
      },
      "FunctionType": {
        "type": "object",
        "properties": {
          "resultType": {
            "$ref": "#/components/schemas/v1alpha1.Type"
          },
          "argTypes": {
            "type": "array",
            "description": "Argument types of the function.",
            "items": {
              "$ref": "#/components/schemas/v1alpha1.Type"
            }
          }
        },
        "description": "Function type with result and arg types."
      },
      "HealthResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string"
          }
        }
      },
      "Ident": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Required. Holds a single, unqualified identifier, possibly preceded by a\n'.'.\n\nQualified names are represented by the [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression."
          }
        },
        "description": "An identifier expression. e.g. `request`."
      },
      "Leaf": {
        "type": "object",
        "properties": {
          "computedUserSet": {
            "$ref": "#/components/schemas/ComputedUserSet"
          },
          "tupleToUserSet": {
            "$ref": "#/components/schemas/TupleToUserSet"
          },
          "computedAttribute": {
            "$ref": "#/components/schemas/ComputedAttribute"
          },
          "call": {
            "$ref": "#/components/schemas/v1.Call"
          }
        },
        "description": "Leaf represents a leaf node in the permission tree."
      },
      "ListType": {
        "type": "object",
        "properties": {
          "elemType": {
            "$ref": "#/components/schemas/v1alpha1.Type"
          }
        },
        "description": "List type with typed elements, e.g. `list<example.proto.MyMessage>`."
      },
      "LookupEntityBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/PermissionLookupEntityRequestMetadata"
          },
          "entity_type": {
            "type": "string",
            "description": "Type of the entity to lookup, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes."
          },
          "permission": {
            "type": "string",
            "description": "Name of the permission to check, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes."
          },
          "subject": {
            "$ref": "#/components/schemas/Subject"
          },
          "context": {
            "$ref": "#/components/schemas/Context"
          },
          "page_size": {
            "type": "integer",
            "description": "page_size is the number of tenants to be returned in the response.\nThe value should be between 1 and 100.",
            "format": "int64"
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is an optional parameter used for pagination.\nIt should be the value received in the previous response."
          }
        },
        "description": "PermissionLookupEntityRequest is the request message for the LookupEntity method in the Permission service."
      },
      "LookupEntityStreamBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/PermissionLookupEntityRequestMetadata"
          },
          "entity_type": {
            "type": "string",
            "description": "Type of the entity to lookup, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes."
          },
          "permission": {
            "type": "string",
            "description": "Name of the permission to check, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes."
          },
          "subject": {
            "$ref": "#/components/schemas/Subject"
          },
          "context": {
            "$ref": "#/components/schemas/Context"
          },
          "page_size": {
            "type": "integer",
            "description": "page_size is the number of tenants to be returned in the response.\nThe value should be between 1 and 100.",
            "format": "int64"
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is an optional parameter used for pagination.\nIt should be the value received in the previous response."
          }
        },
        "description": "PermissionLookupEntityRequest is the request message for the LookupEntity method in the Permission service."
      },
      "LookupSubjectBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/PermissionLookupSubjectRequestMetadata"
          },
          "entity": {
            "$ref": "#/components/schemas/Entity"
          },
          "permission": {
            "type": "string",
            "description": "Permission to be checked, can be a permission or relation. Required, and must match the pattern \"^([a-zA-Z][a-zA-Z0-9_]{1,62}[a-zA-Z0-9])$\", max 64 bytes."
          },
          "subject_reference": {
            "$ref": "#/components/schemas/RelationReference"
          },
          "context": {
            "$ref": "#/components/schemas/Context"
          },
          "page_size": {
            "type": "integer",
            "description": "page_size is the number of tenants to be returned in the response.\nThe value should be between 1 and 100.",
            "format": "int64"
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is an optional parameter used for pagination.\nIt should be the value received in the previous response."
          }
        },
        "description": "PermissionLookupSubjectRequest is the request message for the LookupSubject method in the Permission service."
      },
      "MapType": {
        "type": "object",
        "properties": {
          "keyType": {
            "$ref": "#/components/schemas/v1alpha1.Type"
          },
          "valueType": {
            "$ref": "#/components/schemas/v1alpha1.Type"
          }
        },
        "description": "Map type with parameterized key and value types, e.g. `map<string, int>`."
      },
      "NullValue": {
        "type": "string",
        "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value.",
        "default": "NULL_VALUE",
        "enum": [
          "NULL_VALUE"
        ]
      },
      "PartialWriteBody": {
        "title": "It contains the tenant_id to identify the tenant and metadata of the schema to be edited,\nwith the corresponding edits to various entities",
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/SchemaPartialWriteRequestMetadata"
          },
          "partials": {
            "title": "Map of entity name with the values needed to be updated",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Partials"
            }
          }
        }
      },
      "Partials": {
        "title": "Partials contains the write, update and delete definitions",
        "type": "object",
        "properties": {
          "write": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "delete": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "update": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Permission.CheckBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/PermissionCheckRequestMetadata"
          },
          "entity": {
            "$ref": "#/components/schemas/Entity"
          },
          "permission": {
            "type": "string",
            "description": "The action the user wants to perform on the resource"
          },
          "subject": {
            "$ref": "#/components/schemas/Subject"
          },
          "context": {
            "$ref": "#/components/schemas/Context"
          },
          "arguments": {
            "type": "array",
            "description": "Additional arguments associated with this request.",
            "items": {
              "$ref": "#/components/schemas/Argument"
            }
          }
        },
        "description": "PermissionCheckRequest is the request message for the Check method in the Permission service."
      },
      "Permission.ExpandBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/PermissionExpandRequestMetadata"
          },
          "entity": {
            "$ref": "#/components/schemas/Entity"
          },
          "permission": {
            "type": "string",
            "description": "Name of the permission to be expanded, not required, must start with a letter and can include alphanumeric and underscore, max 64 bytes."
          },
          "context": {
            "$ref": "#/components/schemas/Context"
          },
          "arguments": {
            "type": "array",
            "description": "Additional arguments associated with this request.",
            "items": {
              "$ref": "#/components/schemas/Argument"
            }
          }
        },
        "description": "PermissionExpandRequest is the request message for the Expand method in the Permission service."
      },
      "PermissionCheckRequestMetadata": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "Version of the schema."
          },
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)"
          },
          "depth": {
            "type": "integer",
            "description": "Query limit when if recursive database queries got in loop",
            "format": "int32"
          }
        },
        "description": "PermissionCheckRequestMetadata metadata for the PermissionCheckRequest."
      },
      "PermissionCheckResponse": {
        "type": "object",
        "properties": {
          "can": {
            "$ref": "#/components/schemas/CheckResult"
          },
          "metadata": {
            "$ref": "#/components/schemas/PermissionCheckResponseMetadata"
          }
        },
        "description": "PermissionCheckResponse is the response message for the Check method in the Permission service."
      },
      "PermissionCheckResponseMetadata": {
        "type": "object",
        "properties": {
          "check_count": {
            "type": "integer",
            "description": "The count of the checks performed.",
            "format": "int32"
          }
        },
        "description": "PermissionCheckResponseMetadata metadata for the PermissionCheckResponse."
      },
      "PermissionDefinition": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the permission, which follows a specific string pattern and has a maximum byte size."
          },
          "child": {
            "$ref": "#/components/schemas/Child"
          }
        },
        "description": "The PermissionDefinition message provides detailed information about a specific permission."
      },
      "PermissionExpandRequestMetadata": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "Version of the schema."
          },
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)."
          }
        },
        "description": "PermissionExpandRequestMetadata metadata for the PermissionExpandRequest."
      },
      "PermissionExpandResponse": {
        "type": "object",
        "properties": {
          "tree": {
            "$ref": "#/components/schemas/v1.Expand"
          }
        },
        "description": "PermissionExpandResponse is the response message for the Expand method in the Permission service."
      },
      "PermissionLookupEntityRequestMetadata": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "Version of the schema."
          },
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)."
          },
          "depth": {
            "type": "integer",
            "description": "Query limit when if recursive database queries got in loop.",
            "format": "int32"
          }
        },
        "description": "PermissionLookupEntityRequestMetadata metadata for the PermissionLookupEntityRequest."
      },
      "PermissionLookupEntityResponse": {
        "type": "object",
        "properties": {
          "entity_ids": {
            "type": "array",
            "description": "List of identifiers for entities that match the lookup.",
            "items": {
              "type": "string"
            }
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is a string that can be used to paginate and retrieve the next set of results."
          }
        },
        "description": "PermissionLookupEntityResponse is the response message for the LookupEntity method in the Permission service."
      },
      "PermissionLookupEntityStreamResponse": {
        "type": "object",
        "properties": {
          "entity_id": {
            "type": "string",
            "description": "Identifier for an entity that matches the lookup."
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is a string that can be used to paginate and retrieve the next set of results."
          }
        },
        "description": "PermissionLookupEntityStreamResponse is the response message for the LookupEntityStream method in the Permission service."
      },
      "PermissionLookupSubjectRequestMetadata": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "Version of the schema."
          },
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)."
          },
          "depth": {
            "type": "integer",
            "description": "Query limit when if recursive database queries got in loop.",
            "format": "int32"
          }
        },
        "description": "PermissionLookupSubjectRequestMetadata metadata for the PermissionLookupSubjectRequest."
      },
      "PermissionLookupSubjectResponse": {
        "type": "object",
        "properties": {
          "subject_ids": {
            "type": "array",
            "description": "List of identifiers for subjects that match the lookup.",
            "items": {
              "type": "string"
            }
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is a string that can be used to paginate and retrieve the next set of results."
          }
        },
        "description": "PermissionLookupSubjectResponse is the response message for the LookupSubject method in the Permission service."
      },
      "PermissionSubjectPermissionRequestMetadata": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "Version of the schema."
          },
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)."
          },
          "only_permission": {
            "type": "boolean",
            "description": "Whether to only check permissions."
          },
          "depth": {
            "type": "integer",
            "description": "Query limit when if recursive database queries got in loop.",
            "format": "int32"
          }
        },
        "description": "PermissionSubjectPermissionRequestMetadata metadata for the PermissionSubjectPermissionRequest."
      },
      "PermissionSubjectPermissionResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/CheckResult"
            },
            "description": "Map of results for each permission check."
          }
        },
        "description": "PermissionSubjectPermissionResponse is the response message for the SubjectPermission method in the Permission service."
      },
      "PrimitiveType": {
        "type": "string",
        "description": "CEL primitive types.\n\n - PRIMITIVE_TYPE_UNSPECIFIED: Unspecified type.\n - BOOL: Boolean type.\n - INT64: Int64 type.\n\nProto-based integer values are widened to int64.\n - UINT64: Uint64 type.\n\nProto-based unsigned integer values are widened to uint64.\n - DOUBLE: Double type.\n\nProto-based float values are widened to double values.\n - STRING: String type.\n - BYTES: Bytes type.",
        "default": "PRIMITIVE_TYPE_UNSPECIFIED",
        "enum": [
          "PRIMITIVE_TYPE_UNSPECIFIED",
          "BOOL",
          "INT64",
          "UINT64",
          "DOUBLE",
          "STRING",
          "BYTES"
        ]
      },
      "ReadAttributesBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/AttributeReadRequestMetadata"
          },
          "filter": {
            "$ref": "#/components/schemas/AttributeFilter"
          },
          "page_size": {
            "type": "integer",
            "description": "page_size specifies the number of results to return in a single page.\nIf more results are available, a continuous_token is included in the response.",
            "format": "int64"
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is used in case of paginated reads to get the next page of results."
          }
        },
        "description": "AttributeReadRequest defines the structure of a request for reading attributes.\nIt includes the tenant_id, metadata, attribute filter, page size for pagination, and a continuous token for multi-page results."
      },
      "ReadRelationshipsBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/RelationshipReadRequestMetadata"
          },
          "filter": {
            "$ref": "#/components/schemas/TupleFilter"
          },
          "page_size": {
            "type": "integer",
            "description": "page_size specifies the number of results to return in a single page.\nIf more results are available, a continuous_token is included in the response.",
            "format": "int64"
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is used in case of paginated reads to get the next page of results."
          }
        },
        "description": "RelationshipReadRequest defines the structure of a request for reading relationships.\nIt contains the necessary information such as tenant_id, metadata, and filter for the read operation."
      },
      "RelationDefinition": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the relation, which follows a specific string pattern and has a maximum byte size."
          },
          "relationReferences": {
            "type": "array",
            "description": "A list of references to other relations.",
            "items": {
              "$ref": "#/components/schemas/RelationReference"
            }
          }
        },
        "description": "The RelationDefinition message provides detailed information about a specific relation."
      },
      "RelationReference": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of the referenced entity, which follows a specific string pattern and has a maximum byte size."
          },
          "relation": {
            "type": "string",
            "description": "The name of the referenced relation, which follows a specific string pattern and has a maximum byte size."
          }
        },
        "description": "The RelationReference message provides a reference to a specific relation."
      },
      "RelationshipDeleteResponse": {
        "title": "RelationshipDeleteResponse",
        "type": "object",
        "properties": {
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)"
          }
        }
      },
      "RelationshipReadRequestMetadata": {
        "type": "object",
        "properties": {
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)"
          }
        },
        "description": "RelationshipReadRequestMetadata defines the structure of the metadata for a read request focused on relationships.\nIt includes the snap_token associated with a particular state of the database."
      },
      "RelationshipReadResponse": {
        "type": "object",
        "properties": {
          "tuples": {
            "type": "array",
            "description": "tuples is a list of the relationships retrieved in the read operation, represented as entity-relation-entity triples.",
            "items": {
              "$ref": "#/components/schemas/Tuple"
            }
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is used in the case of paginated reads to retrieve the next page of results."
          }
        },
        "description": "RelationshipReadResponse defines the structure of the response after reading relationships.\nIt includes the tuples representing the relationships and a continuous token for handling result pagination."
      },
      "RelationshipWriteRequestMetadata": {
        "title": "RelationshipWriteRequestMetadata",
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string"
          }
        }
      },
      "RelationshipWriteResponse": {
        "title": "RelationshipWriteResponse",
        "type": "object",
        "properties": {
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)"
          }
        }
      },
      "Rewrite": {
        "type": "object",
        "properties": {
          "rewriteOperation": {
            "$ref": "#/components/schemas/Rewrite.Operation"
          },
          "children": {
            "type": "array",
            "description": "A list of children that are operated upon by the rewrite operation.",
            "items": {
              "$ref": "#/components/schemas/Child"
            }
          }
        },
        "description": "The Rewrite message represents a specific rewrite operation.\nThis operation could be one of the following: union, intersection, or exclusion."
      },
      "Rewrite.Operation": {
        "type": "string",
        "description": "Operation enum includes potential rewrite operations.\nOPERATION_UNION: Represents a union operation.\nOPERATION_INTERSECTION: Represents an intersection operation.\nOPERATION_EXCLUSION: Represents an exclusion operation.\n\n - OPERATION_UNSPECIFIED: Default, unspecified operation.\n - OPERATION_UNION: Represents a union operation.\n - OPERATION_INTERSECTION: Represents an intersection operation.\n - OPERATION_EXCLUSION: Represents an exclusion operation.",
        "default": "OPERATION_UNSPECIFIED",
        "enum": [
          "OPERATION_UNSPECIFIED",
          "OPERATION_UNION",
          "OPERATION_INTERSECTION",
          "OPERATION_EXCLUSION"
        ]
      },
      "RuleDefinition": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the rule, which follows a specific string pattern and has a maximum byte size."
          },
          "arguments": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/AttributeType"
            },
            "description": "Map of arguments for this rule. The key is the attribute name, and the value is the AttributeType."
          },
          "expression": {
            "$ref": "#/components/schemas/CheckedExpr"
          }
        },
        "description": "The RuleDefinition message provides detailed information about a specific rule."
      },
      "RunBundleBody": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the bundle to be executed."
          },
          "arguments": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional key-value pairs for execution arguments."
          }
        },
        "description": "BundleRunRequest is used to request the execution of a bundle.\nIt includes tenant_id, the name of the bundle, and additional arguments for execution."
      },
      "Schema.ListBody": {
        "type": "object",
        "properties": {
          "page_size": {
            "type": "integer",
            "description": "page_size is the number of tenants to be returned in the response.\nThe value should be between 1 and 100.",
            "format": "int64"
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is an optional parameter used for pagination.\nIt should be the value received in the previous response."
          }
        },
        "description": "SchemaListRequest is the request message for the List method in the Schema service.\nIt contains tenant_id for which the schemas are to be listed."
      },
      "Schema.ReadBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/SchemaReadRequestMetadata"
          }
        },
        "description": "SchemaReadRequest is the request message for the Read method in the Schema service.\nIt contains tenant_id and metadata about the schema to be read."
      },
      "Schema.WriteBody": {
        "type": "object",
        "properties": {
          "schema": {
            "type": "string",
            "description": "schema is the string representation of the schema to be written."
          }
        },
        "description": "SchemaWriteRequest is the request message for the Write method in the Schema service.\nIt contains tenant_id and the schema to be written."
      },
      "SchemaDefinition": {
        "type": "object",
        "properties": {
          "entityDefinitions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/EntityDefinition"
            },
            "description": "Map of entity definitions. The key is the entity name, and the value is the corresponding EntityDefinition."
          },
          "ruleDefinitions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/RuleDefinition"
            },
            "description": "Map of rule definitions. The key is the rule name, and the value is the corresponding RuleDefinition."
          },
          "references": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/SchemaDefinition.Reference"
            },
            "description": "Map of references to signify whether a string refers to an entity or a rule."
          }
        },
        "description": "The SchemaDefinition message provides definitions for entities and rules,\nand includes references to clarify whether a name refers to an entity or a rule."
      },
      "SchemaDefinition.Reference": {
        "type": "string",
        "description": "The Reference enum helps distinguish whether a name corresponds to an entity or a rule.\n\n - REFERENCE_UNSPECIFIED: Default, unspecified reference.\n - REFERENCE_ENTITY: Indicates that the name refers to an entity.\n - REFERENCE_RULE: Indicates that the name refers to a rule.",
        "default": "REFERENCE_UNSPECIFIED",
        "enum": [
          "REFERENCE_UNSPECIFIED",
          "REFERENCE_ENTITY",
          "REFERENCE_RULE"
        ]
      },
      "SchemaList": {
        "title": "SchemaList provides a list of schema versions with their corresponding creation timestamps",
        "type": "object",
        "properties": {
          "version": {
            "type": "string"
          },
          "created_at": {
            "type": "string"
          }
        }
      },
      "SchemaListResponse": {
        "title": "SchemaListResponse is the response message for the List method in the Schema service.\nIt returns a paginated list of schemas",
        "type": "object",
        "properties": {
          "head": {
            "title": "head of the schemas is the latest version available for the tenant",
            "type": "string"
          },
          "schemas": {
            "title": "list of schema versions with creation timestamps",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SchemaList"
            }
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is a string that can be used to paginate and retrieve the next set of results."
          }
        }
      },
      "SchemaPartialWriteRequestMetadata": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "schema_version is the string that identifies the version of the schema to be read."
          }
        },
        "description": "SchemaPartialWriteRequestMetadata provides additional information for the Schema Partial Write request.\nIt contains schema_version to specify which version of the schema should be read."
      },
      "SchemaPartialWriteResponse": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "schema_version is the string that identifies the version of the written schema."
          }
        },
        "description": "SchemaPartialWriteResponse is the response message for the Parietal Write method in the Schema service.\nIt returns the requested schema."
      },
      "SchemaReadRequestMetadata": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "schema_version is the string that identifies the version of the schema to be read."
          }
        },
        "description": "SchemaReadRequestMetadata provides additional information for the Schema Read request.\nIt contains schema_version to specify which version of the schema should be read."
      },
      "SchemaReadResponse": {
        "type": "object",
        "properties": {
          "schema": {
            "$ref": "#/components/schemas/SchemaDefinition"
          }
        },
        "description": "SchemaReadResponse is the response message for the Read method in the Schema service.\nIt returns the requested schema."
      },
      "SchemaWriteResponse": {
        "type": "object",
        "properties": {
          "schema_version": {
            "type": "string",
            "description": "schema_version is the string that identifies the version of the written schema."
          }
        },
        "description": "SchemaWriteResponse is the response message for the Write method in the Schema service.\nIt returns the version of the written schema."
      },
      "Select": {
        "type": "object",
        "properties": {
          "operand": {
            "$ref": "#/components/schemas/Expr"
          },
          "field": {
            "type": "string",
            "description": "Required. The name of the field to select.\n\nFor example, in the select expression `request.auth`, the `auth` portion\nof the expression would be the `field`."
          },
          "testOnly": {
            "type": "boolean",
            "description": "Whether the select is to be interpreted as a field presence test.\n\nThis results from the macro `has(request.auth)`."
          }
        },
        "description": "A field selection expression. e.g. `request.auth`."
      },
      "SourceInfo": {
        "type": "object",
        "properties": {
          "syntaxVersion": {
            "type": "string",
            "description": "The syntax version of the source, e.g. `cel1`."
          },
          "location": {
            "type": "string",
            "description": "The location name. All position information attached to an expression is\nrelative to this location.\n\nThe location could be a file, UI element, or similar. For example,\n`acme/app/AnvilPolicy.cel`."
          },
          "lineOffsets": {
            "type": "array",
            "description": "Monotonically increasing list of code point offsets where newlines\n`\\n` appear.\n\nThe line number of a given position is the index `i` where for a given\n`id` the `line_offsets[i] < id_positions[id] < line_offsets[i+1]`. The\ncolumn may be derivd from `id_positions[id] - line_offsets[i]`.",
            "items": {
              "type": "integer",
              "format": "int32"
            }
          },
          "positions": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "int32"
            },
            "description": "A map from the parse node id (e.g. `Expr.id`) to the code point offset\nwithin the source."
          },
          "macroCalls": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Expr"
            },
            "description": "A map from the parse node id where a macro replacement was made to the\ncall `Expr` that resulted in a macro expansion.\n\nFor example, `has(value.field)` is a function call that is replaced by a\n`test_only` field selection in the AST. Likewise, the call\n`list.exists(e, e > 10)` translates to a comprehension expression. The key\nin the map corresponds to the expression id of the expanded macro, and the\nvalue is the call `Expr` that was replaced."
          }
        },
        "description": "Source information collected at parse time."
      },
      "Status": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "format": "int32"
          },
          "message": {
            "type": "string"
          },
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Any"
            }
          }
        }
      },
      "Subject": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "relation": {
            "type": "string"
          }
        },
        "description": "Subject represents an entity subject with a type, an identifier, and a relation."
      },
      "SubjectFilter": {
        "type": "object",
        "properties": {
          "type": {
            "title": "Type of the subject",
            "type": "string"
          },
          "ids": {
            "title": "List of subject IDs",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "relation": {
            "type": "string"
          }
        },
        "description": "SubjectFilter is used to filter subjects based on the type, ids and relation."
      },
      "SubjectPermissionBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/PermissionSubjectPermissionRequestMetadata"
          },
          "entity": {
            "$ref": "#/components/schemas/Entity"
          },
          "subject": {
            "$ref": "#/components/schemas/Subject"
          },
          "context": {
            "$ref": "#/components/schemas/Context"
          }
        },
        "description": "PermissionSubjectPermissionRequest is the request message for the SubjectPermission method in the Permission service."
      },
      "Subjects": {
        "type": "object",
        "properties": {
          "subjects": {
            "type": "array",
            "description": "A list of subjects.",
            "items": {
              "$ref": "#/components/schemas/Subject"
            }
          }
        },
        "description": "Subjects holds a repeated field of Subject type."
      },
      "Tenant": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the tenant."
          },
          "name": {
            "type": "string",
            "description": "The name of the tenant."
          },
          "created_at": {
            "type": "string",
            "description": "The time at which the tenant was created.",
            "format": "date-time"
          }
        },
        "description": "Tenant represents a tenant with an id, a name, and a timestamp indicating when it was created."
      },
      "TenantCreateRequest": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "id is a unique identifier for the tenant."
          },
          "name": {
            "type": "string",
            "description": "name is the name of the tenant."
          }
        },
        "description": "TenantCreateRequest is the message used for the request to create a tenant."
      },
      "TenantCreateResponse": {
        "type": "object",
        "properties": {
          "tenant": {
            "$ref": "#/components/schemas/Tenant"
          }
        },
        "description": "TenantCreateResponse is the message returned from the request to create a tenant."
      },
      "TenantDeleteResponse": {
        "type": "object",
        "properties": {
          "tenant": {
            "$ref": "#/components/schemas/Tenant"
          }
        },
        "description": "TenantDeleteResponse is the message returned from the request to delete a tenant."
      },
      "TenantListRequest": {
        "type": "object",
        "properties": {
          "page_size": {
            "type": "integer",
            "description": "page_size is the number of tenants to be returned in the response.\nThe value should be between 1 and 100.",
            "format": "int64"
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is an optional parameter used for pagination.\nIt should be the value received in the previous response."
          }
        },
        "description": "TenantListRequest is the message used for the request to list all tenants."
      },
      "TenantListResponse": {
        "type": "object",
        "properties": {
          "tenants": {
            "type": "array",
            "description": "tenants is a list of tenants.",
            "items": {
              "$ref": "#/components/schemas/Tenant"
            }
          },
          "continuous_token": {
            "type": "string",
            "description": "continuous_token is a string that can be used to paginate and retrieve the next set of results."
          }
        },
        "description": "TenantListResponse is the message returned from the request to list all tenants."
      },
      "Tuple": {
        "type": "object",
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/Entity"
          },
          "relation": {
            "type": "string"
          },
          "subject": {
            "$ref": "#/components/schemas/Subject"
          }
        },
        "description": "Tuple is a structure that includes an entity, a relation, and a subject."
      },
      "TupleFilter": {
        "type": "object",
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/EntityFilter"
          },
          "relation": {
            "type": "string"
          },
          "subject": {
            "$ref": "#/components/schemas/SubjectFilter"
          }
        },
        "description": "TupleFilter is used to filter tuples based on the entity, relation and the subject."
      },
      "TupleSet": {
        "type": "object",
        "properties": {
          "relation": {
            "type": "string"
          }
        },
        "description": "TupleSet represents a set of tuples associated with a specific relation."
      },
      "TupleToUserSet": {
        "type": "object",
        "properties": {
          "tupleSet": {
            "$ref": "#/components/schemas/TupleSet"
          },
          "computed": {
            "$ref": "#/components/schemas/ComputedUserSet"
          }
        },
        "description": "TupleToUserSet defines a mapping from tuple sets to computed user sets."
      },
      "Values": {
        "type": "object",
        "properties": {
          "values": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Any"
            }
          }
        }
      },
      "WatchBody": {
        "type": "object",
        "properties": {
          "snap_token": {
            "type": "string",
            "description": "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)."
          }
        },
        "description": "WatchRequest is the request message for the Watch RPC. It contains the\ndetails needed to establish a watch stream."
      },
      "WatchResponse": {
        "type": "object",
        "properties": {
          "changes": {
            "$ref": "#/components/schemas/DataChanges"
          }
        },
        "description": "WatchResponse is the response message for the Watch RPC. It contains the\nchanges in the data that are being watched."
      },
      "WellKnownType": {
        "type": "string",
        "description": "Well-known protobuf types treated with first-class support in CEL.\n\n - WELL_KNOWN_TYPE_UNSPECIFIED: Unspecified type.\n - ANY: Well-known protobuf.Any type.\n\nAny types are a polymorphic message type. During type-checking they are\ntreated like `DYN` types, but at runtime they are resolved to a specific\nmessage type specified at evaluation time.\n - TIMESTAMP: Well-known protobuf.Timestamp type, internally referenced as `timestamp`.\n - DURATION: Well-known protobuf.Duration type, internally referenced as `duration`.",
        "default": "WELL_KNOWN_TYPE_UNSPECIFIED",
        "enum": [
          "WELL_KNOWN_TYPE_UNSPECIFIED",
          "ANY",
          "TIMESTAMP",
          "DURATION"
        ]
      },
      "WriteRelationshipsBody": {
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/RelationshipWriteRequestMetadata"
          },
          "tuples": {
            "type": "array",
            "description": "List of tuples for the request. Must have between 1 and 100 items.",
            "items": {
              "$ref": "#/components/schemas/Tuple"
            }
          }
        },
        "description": "Represents a request to write relationship data."
      },
      "v1.Call": {
        "type": "object",
        "properties": {
          "ruleName": {
            "title": "Name of the rule",
            "type": "string"
          },
          "arguments": {
            "title": "Arguments passed to the rule",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Argument"
            }
          }
        },
        "description": "Call represents a call to a rule. It includes the name of the rule and the arguments passed to it."
      },
      "v1.Expand": {
        "type": "object",
        "description": "Expand is used to define a hierarchical structure for permissions.\nIt has an entity, permission, and arguments. The node can be either another hierarchical structure or a set of subjects."
      },
      "v1.Operation": {
        "type": "object",
        "properties": {
          "relationships_write": {
            "type": "array",
            "description": "'relationships_write' is a repeated string field for storing relationship keys\nthat are to be written or created.",
            "items": {
              "type": "string"
            }
          },
          "relationships_delete": {
            "type": "array",
            "description": "'relationships_delete' is a repeated string field for storing relationship keys\nthat are to be deleted or removed.",
            "items": {
              "type": "string"
            }
          },
          "attributes_write": {
            "type": "array",
            "description": "'attributes_write' is a repeated string field for storing attribute keys\nthat are to be written or created.",
            "items": {
              "type": "string"
            }
          },
          "attributes_delete": {
            "type": "array",
            "description": "'attributes_delete' is a repeated string field for storing attribute keys\nthat are to be deleted or removed.",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "Operation is a message representing a series of operations that can be performed.\nIt includes fields for writing and deleting relationships and attributes."
      },
      "v1alpha1.Reference": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The fully qualified name of the declaration."
          },
          "overloadId": {
            "type": "array",
            "description": "For references to functions, this is a list of `Overload.overload_id`\nvalues which match according to typing rules.\n\nIf the list has more than one element, overload resolution among the\npresented candidates must happen at runtime because of dynamic types. The\ntype checker attempts to narrow down this list as much as possible.\n\nEmpty if this is not a reference to a\n[Decl.FunctionDecl][google.api.expr.v1alpha1.Decl.FunctionDecl].",
            "items": {
              "type": "string"
            }
          },
          "value": {
            "$ref": "#/components/schemas/Constant"
          }
        },
        "description": "Describes a resolved reference to a declaration."
      },
      "v1alpha1.Type": {
        "type": "object",
        "properties": {
          "dyn": {
            "type": "object",
            "properties": {},
            "description": "Dynamic type."
          },
          "null": {
            "type": "string",
            "description": "Null value."
          },
          "primitive": {
            "$ref": "#/components/schemas/PrimitiveType"
          },
          "wrapper": {
            "$ref": "#/components/schemas/PrimitiveType"
          },
          "wellKnown": {
            "$ref": "#/components/schemas/WellKnownType"
          },
          "listType": {
            "$ref": "#/components/schemas/ListType"
          },
          "mapType": {
            "$ref": "#/components/schemas/MapType"
          },
          "function": {
            "$ref": "#/components/schemas/FunctionType"
          },
          "messageType": {
            "type": "string",
            "description": "Protocol buffer message type.\n\nThe `message_type` string specifies the qualified message type name. For\nexample, `google.plus.Profile`."
          },
          "typeParam": {
            "type": "string",
            "description": "Type param type.\n\nThe `type_param` string specifies the type parameter name, e.g. `list<E>`\nwould be a `list_type` whose element type was a `type_param` type\nnamed `E`."
          },
          "type": {
            "$ref": "#/components/schemas/v1alpha1.Type"
          },
          "error": {
            "type": "object",
            "properties": {},
            "description": "Error type.\n\nDuring type-checking if an expression is an error, its type is propagated\nas the `ERROR` type. This permits the type-checker to discover other\nerrors present in the expression."
          },
          "abstractType": {
            "$ref": "#/components/schemas/AbstractType"
          }
        },
        "description": "Represents a CEL type."
      }
    },
    "securitySchemes": {
      "ApiKeyAuth": {
        "type": "apiKey",
        "name": "Authorization",
        "in": "header"
      }
    }
  },
  "x-original-swagger-version": "2.0"
}