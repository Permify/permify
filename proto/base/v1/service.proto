syntax = "proto3";
package base.v1;

option go_package = "github.com/Permify/permify/pkg/pb/base/v1";

import "base/v1/base.proto";
import "validate/validate.proto";
import "google/api/annotations.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

// ** PERMISSION SERVICE **

// Permission service contains methods to interact with permissions.
service Permission {

  // Check method receives a PermissionCheckRequest and returns a PermissionCheckResponse.
  // It is used to determine whether a specific user has permission to perform an action on a resource.
  // For example, "Can the user 1 push to repository 1?"
  rpc Check(PermissionCheckRequest) returns (PermissionCheckResponse) {
    // HTTP mapping for this method
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/permissions/check"
      body: "*"
    };
    // OpenAPI annotations for this method
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "This method returns a decision about whether user can perform an permission on a certain resource."
      tags: [
        "Permission"
      ]
      operation_id: "permissions.check"
    };
  }

  // Expand method receives a PermissionExpandRequest and returns a PermissionExpandResponse.
  // It expands relationships according to the schema provided.
  rpc Expand(PermissionExpandRequest) returns (PermissionExpandResponse) {
    // HTTP mapping for this method
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/permissions/expand"
      body: "*"
    };
    // OpenAPI annotations for this method
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "expand relationships according to schema"
      tags: [
        "Permission"
      ]
      operation_id: "permissions.expand"
    };
  }

  // LookupEntity method receives a PermissionLookupEntityRequest and returns a PermissionLookupEntityResponse.
  // It is used to retrieve an entity by its identifier.
  rpc LookupEntity(PermissionLookupEntityRequest) returns (PermissionLookupEntityResponse) {
    // HTTP mapping for this method
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/permissions/lookup-entity"
      body: "*"
    };
    // OpenAPI annotations for this method
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Retrieve an entity by its identifier."
      tags: [
        "Permission"
      ]
      operation_id: "permissions.lookupEntity"
    };
  }

  // LookupEntityStream method receives a PermissionLookupEntityRequest and streams a series of PermissionLookupEntityStreamResponse messages.
  // It is used to retrieve entities by their identifiers in a streaming fashion.
  rpc LookupEntityStream(PermissionLookupEntityRequest) returns (stream PermissionLookupEntityStreamResponse) {
    // HTTP mapping for this method
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/permissions/lookup-entity-stream"
      body: "*"
    };
    // OpenAPI annotations for this method
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Stream entities by their identifiers."
      tags: [
        "Permission"
      ]
      operation_id: "permissions.lookupEntityStream"
    };
  }

  // LookupSubject method receives a PermissionLookupSubjectRequest and returns a PermissionLookupSubjectResponse.
  // It is used to retrieve a subject by its identifier.
  rpc LookupSubject(PermissionLookupSubjectRequest) returns (PermissionLookupSubjectResponse) {
    // HTTP mapping for this method
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/permissions/lookup-subject"
      body: "*"
    };
    // OpenAPI annotations for this method
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Retrieve a subject by its identifier."
      tags: [
        "Permission"
      ]
      operation_id: "permissions.lookupSubject"
    };
  }

  // SubjectPermission method receives a PermissionSubjectPermissionRequest and returns a PermissionSubjectPermissionResponse.
  // It is used to retrieve permissions related to a specific subject.
  rpc SubjectPermission(PermissionSubjectPermissionRequest) returns (PermissionSubjectPermissionResponse) {
    // HTTP mapping for this method
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/permissions/subject-permission"
      body: "*"
    };
    // OpenAPI annotations for this method
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Retrieve permissions related to a specific subject."
      tags: [
        "Permission"
      ]
      operation_id: "permissions.subjectPermission"
    };
  }
}

// CHECK

// PermissionCheckRequest is the request message for the Check method in the Permission service.
message PermissionCheckRequest {

  // Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern : "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes : 128,
    ignore_empty: false,
  }];

  // Metadata associated with this request, required.
  PermissionCheckRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // Entity on which the permission needs to be checked, required.
  Entity entity = 3 [json_name = "entity", (validate.rules).message.required = true];

  // Name of the permission or relation, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
  string permission = 4 [json_name = "permission", (validate.rules).string = {
    pattern : "^[a-zA-Z_]{1,64}$",
    max_bytes : 64,
    ignore_empty: false,
  }];

  // Subject for which the permission needs to be checked, required.
  Subject subject = 5 [json_name = "subject", (validate.rules).message.required = true];

  // Context associated with this request.
  Context context = 6 [json_name = "context"];

  // Additional arguments associated with this request.
  repeated Argument arguments = 7 [json_name = "arguments"];
}

// PermissionCheckRequestMetadata is the metadata associated with a PermissionCheckRequest.
message PermissionCheckRequestMetadata {

  // Version of the schema.
  string schema_version = 1 [json_name = "schema_version"];

  // Token associated with the snap.
  string snap_token = 2 [json_name = "snap_token"];

  // Depth of the check, must be greater than or equal to 3.
  int32 depth = 3 [json_name = "depth", (validate.rules).int32.gte = 3];
}

// PermissionCheckResponse is the response message for the Check method in the Permission service.
message PermissionCheckResponse {

  // Result of the permission check.
  CheckResult can = 1 [json_name = "can"];

  // Metadata associated with this response.
  PermissionCheckResponseMetadata metadata = 2 [json_name = "metadata"];
}

// PermissionCheckResponseMetadata is the metadata associated with a PermissionCheckResponse.
message PermissionCheckResponseMetadata {

  // The count of the checks performed.
  int32 check_count = 1 [json_name = "check_count"];
}

// EXPAND

// PermissionExpandRequest is the request message for the Expand method in the Permission service.
message PermissionExpandRequest {

  // Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern : "[a-zA-Z0-9-,]+",
    max_bytes : 64,
    ignore_empty: false,
  }];

  // Metadata associated with this request, required.
  PermissionExpandRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // Entity on which the permission needs to be expanded, required.
  Entity entity = 3 [json_name = "entity", (validate.rules).message.required = true];

  // Name of the permission to be expanded, not required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
  string permission = 4 [json_name = "permission", (validate.rules).string = {
    pattern : "^[a-zA-Z_]{1,64}$",
    max_bytes : 64,
    ignore_empty: true,
  }];

  // Context associated with this request.
  Context context = 5 [json_name = "context"];

  // Additional arguments associated with this request.
  repeated Argument arguments = 6 [json_name = "arguments"];
}

// PermissionExpandRequestMetadata is the metadata associated with a PermissionExpandRequest.
message PermissionExpandRequestMetadata {

  // Version of the schema.
  string schema_version = 1 [json_name = "schema_version"];

  // Token associated with the snap.
  string snap_token = 2 [json_name = "snap_token"];
}

// PermissionExpandResponse is the response message for the Expand method in the Permission service.
message PermissionExpandResponse {

  // Expansion tree.
  Expand tree = 1 [json_name = "tree"];
}

// LOOKUP ENTITY

// PermissionLookupEntityRequest is the request message for the LookupEntity method in the Permission service.
message PermissionLookupEntityRequest {

  // Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern : "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes : 128,
    ignore_empty: false,
  }];

  // Metadata associated with this request, required.
  PermissionLookupEntityRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // Type of the entity to lookup, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
  string entity_type = 3 [json_name = "entity_type", (validate.rules).string = {
    pattern : "^[a-zA-Z_]{1,64}$",
    max_bytes : 64,
    ignore_empty: false,
  }];

  // Name of the permission to check, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
  string permission = 4 [json_name = "permission", (validate.rules).string = {
    pattern : "^[a-zA-Z_]{1,64}$",
    max_bytes : 64,
    ignore_empty: false,
  }];

  // Subject for which to check the permission, required.
  Subject subject = 5 [json_name = "subject", (validate.rules).message.required = true];

  // Context associated with this request.
  Context context = 6 [json_name = "context"];
}

// PermissionLookupEntityRequestMetadata is the metadata associated with a PermissionLookupEntityRequest.
message PermissionLookupEntityRequestMetadata {

  // Version of the schema.
  string schema_version = 1 [json_name = "schema_version"];

  // Token associated with the snap.
  string snap_token = 2 [json_name = "snap_token"];

  // Depth of lookup, required, must be greater or equal to 3.
  int32 depth = 3 [json_name = "depth", (validate.rules).int32.gte = 3];
}

// PermissionLookupEntityResponse is the response message for the LookupEntity method in the Permission service.
message PermissionLookupEntityResponse {

  // List of identifiers for entities that match the lookup.
  repeated string entity_ids = 1 [json_name = "entity_ids"];
}

// LOOKUP STREAM

// PermissionLookupEntityStreamResponse is the response message for the LookupEntityStream method in the Permission service.
message PermissionLookupEntityStreamResponse {

  // Identifier for an entity that matches the lookup.
  string entity_id = 1 [json_name = "entity_id"];
}

// PermissionEntityFilterRequest is the request message for the LookupEntityStream method in the Permission service.
message PermissionEntityFilterRequest {

  // Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern : "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes : 128,
    ignore_empty: false,
  }];

  // Metadata associated with this request, required.
  PermissionEntityFilterRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // Reference to the entity to filter.
  RelationReference entity_reference = 3 [json_name = "entity_reference"];

  // Subject for which to check the permission.
  Subject subject = 4 [json_name = "subject"];

  // Context associated with this request.
  Context context = 5 [json_name = "context"];
}

// PermissionEntityFilterRequestMetadata is the metadata associated with a PermissionEntityFilterRequest.
message PermissionEntityFilterRequestMetadata {

  // Version of the schema.
  string schema_version = 1 [json_name = "schema_version"];

  // Token associated with the snap.
  string snap_token = 2 [json_name = "snap_token"];

  // Depth of lookup, required, must be greater or equal to 3.
  int32 depth = 3 [json_name = "depth", (validate.rules).int32.gte = 3];
}

// LOOKUP SUBJECT

// PermissionLookupSubjectRequest is the request message for the LookupSubject method in the Permission service.
message PermissionLookupSubjectRequest {

  // Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // Metadata associated with this request, required.
  PermissionLookupSubjectRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // Entity for which to check the permission, required.
  Entity entity = 3 [json_name = "entity", (validate.rules).message.required = true];

  // Permission to be checked, can be a permission or relation. Required, and must match the pattern "^([a-zA-Z][a-zA-Z0-9_]{1,62}[a-zA-Z0-9])$", max 64 bytes.
  string permission = 4 [json_name = "permission", (validate.rules).string = {
    pattern: "^[a-zA-Z_]{1,64}$",
    max_bytes: 64,
    ignore_empty: false,
  }];

  // Reference to the subject to lookup.
  RelationReference subject_reference = 5 [json_name = "subject_reference"];

  // Context associated with this request.
  Context context = 6 [json_name = "context"];
}

// PermissionLookupSubjectRequestMetadata is the metadata associated with a PermissionLookupSubjectRequest.
message PermissionLookupSubjectRequestMetadata {

  // Version of the schema.
  string schema_version = 1 [json_name = "schema_version"];

  // Token associated with the snap.
  string snap_token = 2 [json_name = "snap_token"];

  // Depth of the check, must be greater than or equal to 3.
  int32 depth = 3 [json_name = "depth", (validate.rules).int32.gte = 3];
}

// PermissionLookupSubjectResponse is the response message for the LookupSubject method in the Permission service.
message PermissionLookupSubjectResponse {

  // List of identifiers for subjects that match the lookup.
  repeated string subject_ids = 1 [json_name = "subject_ids"];
}

// SUBJECT PERMISSION

// PermissionSubjectPermissionRequest is the request message for the SubjectPermission method in the Permission service.
message PermissionSubjectPermissionRequest {

  // Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // Metadata associated with this request, required.
  PermissionSubjectPermissionRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // Entity for which to check the permission, required.
  Entity entity = 3 [json_name = "entity", (validate.rules).message.required = true];

  // Subject for which to check the permission, required.
  Subject subject = 4 [json_name = "subject", (validate.rules).message.required = true];

  // Context associated with this request.
  Context context = 5 [json_name = "context"];
}

// PermissionSubjectPermissionRequestMetadata is the metadata associated with a PermissionSubjectPermissionRequest.
message PermissionSubjectPermissionRequestMetadata {

  // Version of the schema.
  string schema_version = 1 [json_name = "schema_version"];

  // Token associated with the snap.
  string snap_token = 2 [json_name = "snap_token"];

  // Whether to only check permissions.
  bool only_permission = 3 [json_name = "only_permission"];

  // Depth of the check, must be greater than or equal to 3.
  int32 depth = 4 [json_name = "depth", (validate.rules).int32.gte = 3];
}

// PermissionSubjectPermissionResponse is the response message for the SubjectPermission method in the Permission service.
message PermissionSubjectPermissionResponse {

  // Map of results for each permission check.
  map<string, CheckResult> results = 1 [json_name = "results"];
}

// ** WATCH SERVICE **

// Watch service provides a streaming RPC that can be used to watch changes in the data.

// Watch is the main RPC in the Watch service. It establishes a stream between
// the client and the server. The server pushes data changes into this stream
// and the client can read those in real time.
service Watch {
  rpc Watch(WatchRequest) returns (stream WatchResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/watch" // HTTP mapping: POST request to the /v1/tenants/{tenant_id}/watch endpoint.
      body: "*" // The entire request message will be the HTTP request body.
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "" // Short summary of what the operation does.
      tags: [
        "Watch" // Adds an additional categorization for the operation.
      ]
      operation_id: "watch.watch" // Unique string used to identify the operation.
    };
  }
}

// WatchRequest is the request message for the Watch RPC. It contains the
// details needed to establish a watch stream.
message WatchRequest {

  // Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern : "[a-zA-Z0-9-,]+",
    max_bytes : 64,
    ignore_empty: false,
  }];

  // Snap token to be used for watching.
  string snap_token = 2 [json_name = "snap_token"];
}

// WatchResponse is the response message for the Watch RPC. It contains the
// changes in the data that are being watched.
message WatchResponse {

  // Changes in the data.
  DataChanges changes = 1 [json_name = "changes"];
}

// ** SCHEMA SERVICE **

// Schema service provides methods to manage the authorization model of your application.
// It allows you to read and write the schema of your authorization model.

// The Schema service definition.
service Schema {

  // Write is an RPC that allows you to write your authorization model.
  rpc Write(SchemaWriteRequest) returns (SchemaWriteResponse) {

    // It maps to HTTP POST requests and the entire request message
    // will be treated as the HTTP request body.
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/schemas/write" // HTTP mapping: POST request to the /v1/tenants/{tenant_id}/schemas/write endpoint.
      body: "*" // The entire request message will be the HTTP request body.
    };

    // OpenAPI specific annotation
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "write your authorization model" // Short summary of what the operation does.
      tags: ["Schema"] // Adds an additional categorization for the operation.
      operation_id: "schemas.write" // Unique string used to identify the operation.
    };
  }

  // Read is an RPC that allows you to read your authorization model.
  rpc Read(SchemaReadRequest) returns (SchemaReadResponse) {

    // It maps to HTTP POST requests and the entire request message
    // will be treated as the HTTP request body.
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/schemas/read" // HTTP mapping: POST request to the /v1/tenants/{tenant_id}/schemas/read endpoint.
      body: "*" // The entire request message will be the HTTP request body.
    };

    // OpenAPI specific annotation
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "read your authorization model" // Short summary of what the operation does.
      tags: ["Schema"] // Adds an additional categorization for the operation.
      operation_id: "schemas.read" // Unique string used to identify the operation.
    };
  }
}

// WRITE

// SchemaWriteRequest is the request message for the Write method in the Schema service.
// It contains tenant_id and the schema to be written.
message SchemaWriteRequest {

  // tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
  // be a maximum of 64 bytes, and must not be empty.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // schema is the string representation of the schema to be written.
  string schema = 2 [json_name = "schema"];
}

// SchemaWriteResponse is the response message for the Write method in the Schema service.
// It returns the version of the written schema.
message SchemaWriteResponse {

  // schema_version is the string that identifies the version of the written schema.
  string schema_version = 1 [json_name = "schema_version"];
}

// READ

// SchemaReadRequest is the request message for the Read method in the Schema service.
// It contains tenant_id and metadata about the schema to be read.
message SchemaReadRequest {

  // tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
  // be a maximum of 64 bytes, and must not be empty.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // metadata is the additional information needed for the Read request.
  SchemaReadRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];
}

// SchemaReadRequestMetadata provides additional information for the Schema Read request.
// It contains schema_version to specify which version of the schema should be read.
message SchemaReadRequestMetadata {

  // schema_version is the string that identifies the version of the schema to be read.
  string schema_version = 1 [json_name = "schema_version"];
}

// SchemaReadResponse is the response message for the Read method in the Schema service.
// It returns the requested schema.
message SchemaReadResponse {

  // schema is the SchemaDefinition that represents the read schema.
  SchemaDefinition schema = 1 [json_name = "schema"];
}

// ** DATA SERVICE **

// The Data service provides RPC methods for managing data in the context of relationships and attributes.
service Data {

  // The Write RPC method creates a new relation tuple.
  rpc Write(DataWriteRequest) returns (DataWriteResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/data/write"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "create data"
      tags: [
        "Data"
      ]
      operation_id: "data.write"
    };
  }

  // RPC method to write relationships for a tenant. This can be accessed via a POST request to the given HTTP path. It's tagged under "Data" in OpenAPI documentation.
  rpc WriteRelationships(RelationshipWriteRequest) returns (RelationshipWriteResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/relationships/write"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "create new relationships"
      tags: [
        "Data"
      ]
      operation_id: "relationships.write"
    };
  }

  // The ReadRelationships RPC method reads relation tuple(s).
  rpc ReadRelationships(RelationshipReadRequest) returns (RelationshipReadResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/data/relationships/read"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "read relation tuple(s)"
      tags: [
        "Data"
      ]
      operation_id: "data.relationships.read"
    };
  }

  // The ReadAttributes RPC method reads attribute(s) of a relation.
  rpc ReadAttributes(AttributeReadRequest) returns (AttributeReadResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/data/attributes/read"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "read attribute(s)"
      tags: [
        "Data"
      ]
      operation_id: "data.attributes.read"
    };
  }

  // The Delete RPC method deletes a relation tuple.
  rpc Delete(DataDeleteRequest) returns (DataDeleteResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/data/delete"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "delete data"
      tags: [
        "Data"
      ]
      operation_id: "data.delete"
    };
  }

  // RPC method to delete relationships for a tenant, accessed via a POST request to the specified path, tagged as "Data" in OpenAPI documentation.
  rpc DeleteRelationships(RelationshipDeleteRequest) returns (RelationshipDeleteResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/relationships/delete"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "delete relationships"
      tags: [
        "Data"
      ]
      operation_id: "relationships.delete"
    };
  }

  // Executes or runs a specific bundle. This method is useful for processing or triggering actions based on the bundle's data.
  rpc RunBundle(BundleRunRequest) returns (BundleRunResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/data/run-bundle"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "run bundle"
      tags: [
        "Data"
      ]
      operation_id: "bundle.run"
    };
  }
}

// DataWriteRequest defines the structure of a request for writing data.
// It contains the necessary information such as tenant_id, metadata,
// tuples and attributes for the write operation.
message DataWriteRequest {
  // tenant_id represents the unique identifier of the tenant for which data is written.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // metadata holds additional data related to the request.
  DataWriteRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // tuples contains the list of tuples (entity-relation-entity triples) that need to be written.
  repeated Tuple tuples = 3 [json_name = "tuples", (validate.rules).repeated = {
    min_items : 0,
    max_items : 100,
    items : {
      message : {
        required : true,
      },
    },
  }];

  // attributes contains the list of attributes (entity-attribute-value triples) that need to be written.
  repeated Attribute attributes = 4 [json_name = "attributes", (validate.rules).repeated = {
    min_items : 0,
    max_items : 100,
    items : {
      message : {
        required : true,
      },
    },
  }];
}

// DataWriteRequestMetadata defines the structure of metadata for a write request.
// It includes the schema version of the data to be written.
message DataWriteRequestMetadata {
  // schema_version represents the version of the schema for the data being written.
  string schema_version = 1 [json_name = "schema_version"];
}

// DataWriteResponse defines the structure of the response after writing data.
// It contains the snap_token generated after the write operation.
message DataWriteResponse {
  // snap_token is the token generated after the data write operation, representing a snapshot of the data.
  string snap_token = 1 [json_name = "snap_token"];
}

// Represents a request to write relationship data.
message RelationshipWriteRequest {

  // Unique identifier for the tenant with specific constraints.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // Metadata for the request. It's required.
  RelationshipWriteRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // List of tuples for the request. Must have between 1 and 100 items.
  repeated Tuple tuples = 3 [json_name = "tuples", (validate.rules).repeated = {
    min_items : 1,
    max_items : 100,
    items : {
      message : {
        required : true,
      },
    },
  }];
}

// RelationshipWriteRequestMetadata
message RelationshipWriteRequestMetadata {
  string schema_version = 1 [json_name = "schema_version"];
}

// RelationshipWriteResponse
message RelationshipWriteResponse {
  string snap_token = 1 [json_name = "snap_token"];
}

// RelationshipReadRequest defines the structure of a request for reading relationships.
// It contains the necessary information such as tenant_id, metadata, and filter for the read operation.
message RelationshipReadRequest {
  // tenant_id represents the unique identifier of the tenant for which relationships are read.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // metadata holds additional data related to the request.
  RelationshipReadRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // filter is used to specify criteria for the data that needs to be read.
  TupleFilter filter = 3 [json_name = "filter", (validate.rules).message.required = true];

  // page_size specifies the number of results to return in a single page.
  // If more results are available, a continuous_token is included in the response.
  uint32 page_size = 4 [
    json_name = "page_size",
    (validate.rules).uint32 = {gte: 1, lte: 100, ignore_empty: true}
  ];

  // continuous_token is used in case of paginated reads to get the next page of results.
  string continuous_token = 5 [json_name = "continuous_token", (validate.rules).string = {ignore_empty: true}];
}

// RelationshipReadRequestMetadata defines the structure of the metadata for a read request focused on relationships.
// It includes the snap_token associated with a particular state of the database.
message RelationshipReadRequestMetadata {
  // snap_token represents a specific state or "snapshot" of the database.
  string snap_token = 1 [json_name = "snap_token"];
}

// RelationshipReadResponse defines the structure of the response after reading relationships.
// It includes the tuples representing the relationships and a continuous token for handling result pagination.
message RelationshipReadResponse {
  // tuples is a list of the relationships retrieved in the read operation, represented as entity-relation-entity triples.
  repeated Tuple tuples = 1 [json_name = "tuples"];

  // continuous_token is used in the case of paginated reads to retrieve the next page of results.
  string continuous_token = 2 [json_name = "continuous_token"];
}

// AttributeReadRequest defines the structure of a request for reading attributes.
// It includes the tenant_id, metadata, attribute filter, page size for pagination, and a continuous token for multi-page results.
message AttributeReadRequest {
  // tenant_id represents the unique identifier of the tenant from which the attributes are being read.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // metadata holds additional information related to the request.
  AttributeReadRequestMetadata metadata = 2 [json_name = "metadata", (validate.rules).message.required = true];

  // filter specifies the criteria used to select the attributes that should be returned.
  AttributeFilter filter = 3 [json_name = "filter", (validate.rules).message.required = true];

  // page_size specifies the number of results to return in a single page.
  // If more results are available, a continuous_token is included in the response.
  uint32 page_size = 4 [
    json_name = "page_size",
    (validate.rules).uint32 = {gte: 1, lte: 100, ignore_empty: true}
  ];

  // continuous_token is used in case of paginated reads to get the next page of results.
  string continuous_token = 5 [json_name = "continuous_token", (validate.rules).string = {ignore_empty: true}];
}

// AttributeReadRequestMetadata defines the structure for the metadata of an attribute read request.
// It includes the snap_token associated with a particular state of the database.
message AttributeReadRequestMetadata {
  // snap_token represents a specific state or "snapshot" of the database.
  string snap_token = 1 [json_name = "snap_token"];
}

// AttributeReadResponse defines the structure of the response to an attribute read request.
// It includes the attributes retrieved and a continuous token for handling result pagination.
message AttributeReadResponse {
  // attributes is a list of the attributes retrieved in the read operation.
  repeated Attribute attributes = 1 [json_name = "attributes"];

  // continuous_token is used in the case of paginated reads to retrieve the next page of results.
  string continuous_token = 2 [json_name = "continuous_token"];
}

// DataDeleteRequest defines the structure of a request to delete data.
// It includes the tenant_id and filters for selecting tuples and attributes to be deleted.
message DataDeleteRequest {
  // tenant_id represents the unique identifier of the tenant from which the data will be deleted.
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // tuple_filter specifies the criteria used to select the tuples that should be deleted.
  TupleFilter tuple_filter = 2 [json_name = "tuple_filter", (validate.rules).message.required = true];

  // attribute_filter specifies the criteria used to select the attributes that should be deleted.
  AttributeFilter attribute_filter = 3 [json_name = "attribute_filter", (validate.rules).message.required = true];
}

// DataDeleteResponse defines the structure of the response to a data delete request.
// It includes a snap_token representing the state of the database after the deletion.
message DataDeleteResponse {
  // snap_token represents the state of the database after the requested deletions.
  string snap_token = 1 [json_name = "snap_token"];
}

// RelationshipDeleteRequest
message RelationshipDeleteRequest {
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  TupleFilter filter = 2 [json_name = "filter"];
}

// RelationshipDeleteResponse
message RelationshipDeleteResponse {
  string snap_token = 1 [json_name = "snap_token"];
}

// BundleRunRequest is used to request the execution of a bundle.
// It includes tenant_id, the name of the bundle, and additional arguments for execution.
message BundleRunRequest {
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  // Name of the bundle to be executed.
  string name = 2 [json_name = "name"];

  // Additional key-value pairs for execution arguments.
  map<string, string> arguments = 3 [json_name = "arguments"];
}

// BundleRunResponse is the response for a BundleRunRequest.
// It includes a snap_token, which may be used for tracking the execution or its results.
message BundleRunResponse {
  string snap_token = 1 [json_name = "snap_token"]; // Token related to the bundle execution.
}

// ** BUNDLE SERVICE **

service Bundle {
  // Writes a bundle of data for a specific operation. This is a general purpose method to handle writing data bundles.
  rpc Write(BundleWriteRequest) returns (BundleWriteResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/bundle/write"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "write bundle"
      tags: [
        "Bundle"
      ]
      operation_id: "bundle.write"
    };
  }

  // Reads a data bundle based on a specified request. This method is tailored for retrieving data bundles.
  rpc Read(BundleReadRequest) returns (BundleReadResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/bundle/read"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "read bundle"
      tags: [
        "Bundle"
      ]
      operation_id: "bundle.read"
    };
  }

  // Deletes a specific data bundle. This method is used to remove existing bundles from the system.
  rpc Delete(BundleDeleteRequest) returns (BundleDeleteResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant_id}/bundle/delete"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "delete bundle"
      tags: [
        "Bundle"
      ]
      operation_id: "bundle.delete"
    };
  }
}

// BundleWriteRequest is used to request the writing of a bundle.
// It contains the tenant_id to identify the tenant and the Bundles object.
message BundleWriteRequest {
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  repeated DataBundle bundles = 2; // Contains the bundle data to be written.
}

// BundleWriteResponse is the response for a BundleWriteRequest.
// It includes a name which could be used as an identifier or acknowledgment.
message BundleWriteResponse {
  repeated string names = 1 [json_name = "names"]; // Identifier or acknowledgment of the written bundle.
}

message BundleReadRequest {
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  string name = 2 [json_name = "name"];
}

message BundleReadResponse {
  DataBundle bundle = 1 [json_name = "bundle"];
}

// BundleDeleteRequest is used to request the deletion of a bundle.
// It contains the tenant_id to specify the tenant and the name of the bundle to be deleted.
message BundleDeleteRequest {
  string tenant_id = 1 [json_name = "tenant_id", (validate.rules).string = {
    pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$",
    max_bytes: 128,
    ignore_empty: false,
  }];

  string name = 2 [json_name = "name"]; // Name of the bundle to be deleted.
}

message BundleDeleteResponse {
  string name = 1 [json_name = "name"];
}

// ** TENANCY SERVICE **
// The Tenancy service defines the gRPC methods for managing tenants.

service Tenancy {
  // Create is a unary RPC to create a new tenant.
  // It requires a TenantCreateRequest and returns a TenantCreateResponse.
  rpc Create(TenantCreateRequest) returns (TenantCreateResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/create"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "create new tenant"
      tags: [
        "Tenancy"
      ]
      operation_id: "tenants.create"
    };
  }

  // Delete is a unary RPC to delete an existing tenant.
  // It requires a TenantDeleteRequest and returns a TenantDeleteResponse.
  rpc Delete(TenantDeleteRequest) returns (TenantDeleteResponse) {
    option (google.api.http) = {
      delete: "/v1/tenants/{id}"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "delete tenant"
      tags: [
        "Tenancy"
      ]
      operation_id: "tenants.delete"
    };
  }

  // List is a unary RPC to get a list of all tenants.
  // It requires a TenantListRequest and returns a TenantListResponse.
  rpc List(TenantListRequest) returns (TenantListResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/list"
      body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "list tenants"
      tags: [
        "Tenancy"
      ]
      operation_id: "tenants.list"
    };
  }
}

// TenantCreateRequest is the message used for the request to create a tenant.
message TenantCreateRequest {
  // id is a unique identifier for the tenant.
  string id = 1 [json_name = "id", (validate.rules).string = {
    pattern : "[a-zA-Z0-9-,]+",
    max_bytes : 64,
    ignore_empty: false,
  }];

  // name is the name of the tenant.
  string name = 2 [json_name = "name", (validate.rules).string = {
    max_bytes : 64,
    ignore_empty: false,
  }];
}

// TenantCreateResponse is the message returned from the request to create a tenant.
message TenantCreateResponse {
  // tenant is the created tenant information.
  Tenant tenant = 1 [json_name = "tenant"];
}

// TenantDeleteRequest is the message used for the request to delete a tenant.
message TenantDeleteRequest {
  // id is the unique identifier of the tenant to be deleted.
  string id = 1 [json_name = "id", (validate.rules).string = {
    ignore_empty: false,
  }];
}

// TenantDeleteResponse is the message returned from the request to delete a tenant.
message TenantDeleteResponse {
  // tenant is the tenant information that was deleted.
  Tenant tenant = 1 [json_name = "tenant"];
}

// TenantListRequest is the message used for the request to list all tenants.
message TenantListRequest {
  // page_size is the number of tenants to be returned in the response.
  // The value should be between 1 and 100.
  uint32 page_size = 1 [
    json_name = "page_size",
    (validate.rules).uint32 = {gte: 1, lte: 100, ignore_empty: true}
  ];

  // continuous_token is an optional parameter used for pagination.
  // It should be the value received in the previous response.
  string continuous_token = 2 [json_name = "continuous_token", (validate.rules).string = {ignore_empty: true}];
}

// TenantListResponse is the message returned from the request to list all tenants.
message TenantListResponse {
  // tenants is a list of tenants.
  repeated Tenant tenants = 1 [json_name = "tenants"];

  // continuous_token is a string that can be used to paginate and retrieve the next set of results.
  string continuous_token = 2 [json_name = "continuous_token"];
}
