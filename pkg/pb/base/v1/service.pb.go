// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: base/v1/service.proto

package basev1

import (
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// PermissionCheckRequest is the request message for the Check method in the Permission service.
type PermissionCheckRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// Metadata associated with this request, required.
	Metadata *PermissionCheckRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Entity on which the permission needs to be checked, required.
	Entity *Entity `protobuf:"bytes,3,opt,name=entity,proto3" json:"entity,omitempty"`
	// Name of the permission or relation, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
	Permission string `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
	// Subject for which the permission needs to be checked, required.
	Subject *Subject `protobuf:"bytes,5,opt,name=subject,proto3" json:"subject,omitempty"`
	// Context associated with this request.
	Context *Context `protobuf:"bytes,6,opt,name=context,proto3" json:"context,omitempty"`
	// Additional arguments associated with this request.
	Arguments     []*Argument `protobuf:"bytes,7,rep,name=arguments,proto3" json:"arguments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionCheckRequest) Reset() {
	*x = PermissionCheckRequest{}
	mi := &file_base_v1_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionCheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionCheckRequest) ProtoMessage() {}

func (x *PermissionCheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionCheckRequest.ProtoReflect.Descriptor instead.
func (*PermissionCheckRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{0}
}

func (x *PermissionCheckRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *PermissionCheckRequest) GetMetadata() *PermissionCheckRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *PermissionCheckRequest) GetEntity() *Entity {
	if x != nil {
		return x.Entity
	}
	return nil
}

func (x *PermissionCheckRequest) GetPermission() string {
	if x != nil {
		return x.Permission
	}
	return ""
}

func (x *PermissionCheckRequest) GetSubject() *Subject {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *PermissionCheckRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PermissionCheckRequest) GetArguments() []*Argument {
	if x != nil {
		return x.Arguments
	}
	return nil
}

// PermissionCheckRequestMetadata metadata for the PermissionCheckRequest.
type PermissionCheckRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version of the schema.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	// Token associated with the snap.
	SnapToken string `protobuf:"bytes,2,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	// Depth of the check, must be greater than or equal to 3.
	Depth         int32 `protobuf:"varint,3,opt,name=depth,proto3" json:"depth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionCheckRequestMetadata) Reset() {
	*x = PermissionCheckRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionCheckRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionCheckRequestMetadata) ProtoMessage() {}

func (x *PermissionCheckRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionCheckRequestMetadata.ProtoReflect.Descriptor instead.
func (*PermissionCheckRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{1}
}

func (x *PermissionCheckRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

func (x *PermissionCheckRequestMetadata) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

func (x *PermissionCheckRequestMetadata) GetDepth() int32 {
	if x != nil {
		return x.Depth
	}
	return 0
}

// PermissionCheckResponse is the response message for the Check method in the Permission service.
type PermissionCheckResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Result of the permission check.
	Can CheckResult `protobuf:"varint,1,opt,name=can,proto3,enum=base.v1.CheckResult" json:"can,omitempty"`
	// Metadata associated with this response.
	Metadata      *PermissionCheckResponseMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionCheckResponse) Reset() {
	*x = PermissionCheckResponse{}
	mi := &file_base_v1_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionCheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionCheckResponse) ProtoMessage() {}

func (x *PermissionCheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionCheckResponse.ProtoReflect.Descriptor instead.
func (*PermissionCheckResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{2}
}

func (x *PermissionCheckResponse) GetCan() CheckResult {
	if x != nil {
		return x.Can
	}
	return CheckResult_CHECK_RESULT_UNSPECIFIED
}

func (x *PermissionCheckResponse) GetMetadata() *PermissionCheckResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// PermissionCheckResponseMetadata metadata for the PermissionCheckResponse.
type PermissionCheckResponseMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The count of the checks performed.
	CheckCount    int32 `protobuf:"varint,1,opt,name=check_count,proto3" json:"check_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionCheckResponseMetadata) Reset() {
	*x = PermissionCheckResponseMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionCheckResponseMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionCheckResponseMetadata) ProtoMessage() {}

func (x *PermissionCheckResponseMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionCheckResponseMetadata.ProtoReflect.Descriptor instead.
func (*PermissionCheckResponseMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{3}
}

func (x *PermissionCheckResponseMetadata) GetCheckCount() int32 {
	if x != nil {
		return x.CheckCount
	}
	return 0
}

// PermissionExpandRequest is the request message for the Expand method in the Permission service.
type PermissionExpandRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// Metadata associated with this request, required.
	Metadata *PermissionExpandRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Entity on which the permission needs to be expanded, required.
	Entity *Entity `protobuf:"bytes,3,opt,name=entity,proto3" json:"entity,omitempty"`
	// Name of the permission to be expanded, not required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
	Permission string `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
	// Context associated with this request.
	Context *Context `protobuf:"bytes,5,opt,name=context,proto3" json:"context,omitempty"`
	// Additional arguments associated with this request.
	Arguments     []*Argument `protobuf:"bytes,6,rep,name=arguments,proto3" json:"arguments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionExpandRequest) Reset() {
	*x = PermissionExpandRequest{}
	mi := &file_base_v1_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionExpandRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionExpandRequest) ProtoMessage() {}

func (x *PermissionExpandRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionExpandRequest.ProtoReflect.Descriptor instead.
func (*PermissionExpandRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{4}
}

func (x *PermissionExpandRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *PermissionExpandRequest) GetMetadata() *PermissionExpandRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *PermissionExpandRequest) GetEntity() *Entity {
	if x != nil {
		return x.Entity
	}
	return nil
}

func (x *PermissionExpandRequest) GetPermission() string {
	if x != nil {
		return x.Permission
	}
	return ""
}

func (x *PermissionExpandRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PermissionExpandRequest) GetArguments() []*Argument {
	if x != nil {
		return x.Arguments
	}
	return nil
}

// PermissionExpandRequestMetadata metadata for the PermissionExpandRequest.
type PermissionExpandRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version of the schema.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	// Token associated with the snap.
	SnapToken     string `protobuf:"bytes,2,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionExpandRequestMetadata) Reset() {
	*x = PermissionExpandRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionExpandRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionExpandRequestMetadata) ProtoMessage() {}

func (x *PermissionExpandRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionExpandRequestMetadata.ProtoReflect.Descriptor instead.
func (*PermissionExpandRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{5}
}

func (x *PermissionExpandRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

func (x *PermissionExpandRequestMetadata) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

// PermissionExpandResponse is the response message for the Expand method in the Permission service.
type PermissionExpandResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Expansion tree.
	Tree          *Expand `protobuf:"bytes,1,opt,name=tree,proto3" json:"tree,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionExpandResponse) Reset() {
	*x = PermissionExpandResponse{}
	mi := &file_base_v1_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionExpandResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionExpandResponse) ProtoMessage() {}

func (x *PermissionExpandResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionExpandResponse.ProtoReflect.Descriptor instead.
func (*PermissionExpandResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{6}
}

func (x *PermissionExpandResponse) GetTree() *Expand {
	if x != nil {
		return x.Tree
	}
	return nil
}

// PermissionLookupEntityRequest is the request message for the LookupEntity method in the Permission service.
type PermissionLookupEntityRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// Metadata associated with this request, required.
	Metadata *PermissionLookupEntityRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Type of the entity to lookup, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
	EntityType string `protobuf:"bytes,3,opt,name=entity_type,proto3" json:"entity_type,omitempty"`
	// Name of the permission to check, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
	Permission string `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
	// Subject for which to check the permission, required.
	Subject *Subject `protobuf:"bytes,5,opt,name=subject,proto3" json:"subject,omitempty"`
	// Context associated with this request.
	Context *Context `protobuf:"bytes,6,opt,name=context,proto3" json:"context,omitempty"`
	// Scope: A map that associates entity types with lists of identifiers. Each entry
	// helps filter requests by specifying which entities are relevant to the operation.
	Scope map[string]*StringArrayValue `protobuf:"bytes,7,rep,name=scope,proto3" json:"scope,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// page_size is the number of entities to be returned in the response.
	// The value should be between 1 and 100.
	PageSize uint32 `protobuf:"varint,8,opt,name=page_size,proto3" json:"page_size,omitempty"`
	// continuous_token is an optional parameter used for pagination.
	// It should be the value received in the previous response.
	ContinuousToken string `protobuf:"bytes,9,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PermissionLookupEntityRequest) Reset() {
	*x = PermissionLookupEntityRequest{}
	mi := &file_base_v1_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionLookupEntityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionLookupEntityRequest) ProtoMessage() {}

func (x *PermissionLookupEntityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionLookupEntityRequest.ProtoReflect.Descriptor instead.
func (*PermissionLookupEntityRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{7}
}

func (x *PermissionLookupEntityRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *PermissionLookupEntityRequest) GetMetadata() *PermissionLookupEntityRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *PermissionLookupEntityRequest) GetEntityType() string {
	if x != nil {
		return x.EntityType
	}
	return ""
}

func (x *PermissionLookupEntityRequest) GetPermission() string {
	if x != nil {
		return x.Permission
	}
	return ""
}

func (x *PermissionLookupEntityRequest) GetSubject() *Subject {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *PermissionLookupEntityRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PermissionLookupEntityRequest) GetScope() map[string]*StringArrayValue {
	if x != nil {
		return x.Scope
	}
	return nil
}

func (x *PermissionLookupEntityRequest) GetPageSize() uint32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *PermissionLookupEntityRequest) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// PermissionLookupEntityRequestMetadata metadata for the PermissionLookupEntityRequest.
type PermissionLookupEntityRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version of the schema.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	// Token associated with the snap.
	SnapToken string `protobuf:"bytes,2,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	// Depth of lookup, required, must be greater or equal to 3.
	Depth         int32 `protobuf:"varint,3,opt,name=depth,proto3" json:"depth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionLookupEntityRequestMetadata) Reset() {
	*x = PermissionLookupEntityRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionLookupEntityRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionLookupEntityRequestMetadata) ProtoMessage() {}

func (x *PermissionLookupEntityRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionLookupEntityRequestMetadata.ProtoReflect.Descriptor instead.
func (*PermissionLookupEntityRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{8}
}

func (x *PermissionLookupEntityRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

func (x *PermissionLookupEntityRequestMetadata) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

func (x *PermissionLookupEntityRequestMetadata) GetDepth() int32 {
	if x != nil {
		return x.Depth
	}
	return 0
}

// PermissionLookupEntityResponse is the response message for the LookupEntity method in the Permission service.
type PermissionLookupEntityResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of identifiers for entities that match the lookup.
	EntityIds []string `protobuf:"bytes,1,rep,name=entity_ids,proto3" json:"entity_ids,omitempty"`
	// continuous_token is a string that can be used to paginate and retrieve the next set of results.
	ContinuousToken string `protobuf:"bytes,2,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PermissionLookupEntityResponse) Reset() {
	*x = PermissionLookupEntityResponse{}
	mi := &file_base_v1_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionLookupEntityResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionLookupEntityResponse) ProtoMessage() {}

func (x *PermissionLookupEntityResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionLookupEntityResponse.ProtoReflect.Descriptor instead.
func (*PermissionLookupEntityResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{9}
}

func (x *PermissionLookupEntityResponse) GetEntityIds() []string {
	if x != nil {
		return x.EntityIds
	}
	return nil
}

func (x *PermissionLookupEntityResponse) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// PermissionLookupEntityStreamResponse is the response message for the LookupEntityStream method in the Permission service.
type PermissionLookupEntityStreamResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier for an entity that matches the lookup.
	EntityId string `protobuf:"bytes,1,opt,name=entity_id,proto3" json:"entity_id,omitempty"`
	// continuous_token is a string that can be used to paginate and retrieve the next set of results.
	ContinuousToken string `protobuf:"bytes,2,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PermissionLookupEntityStreamResponse) Reset() {
	*x = PermissionLookupEntityStreamResponse{}
	mi := &file_base_v1_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionLookupEntityStreamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionLookupEntityStreamResponse) ProtoMessage() {}

func (x *PermissionLookupEntityStreamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionLookupEntityStreamResponse.ProtoReflect.Descriptor instead.
func (*PermissionLookupEntityStreamResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{10}
}

func (x *PermissionLookupEntityStreamResponse) GetEntityId() string {
	if x != nil {
		return x.EntityId
	}
	return ""
}

func (x *PermissionLookupEntityStreamResponse) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// PermissionEntityFilterRequest is the request message for the LookupEntityStream method in the Permission service.
type PermissionEntityFilterRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// Metadata associated with this request, required.
	Metadata *PermissionEntityFilterRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Reference to the entity to filter.
	Entrance *Entrance `protobuf:"bytes,3,opt,name=entrance,proto3" json:"entrance,omitempty"`
	// Subject for which to check the permission.
	Subject *Subject `protobuf:"bytes,4,opt,name=subject,proto3" json:"subject,omitempty"`
	// Context associated with this request.
	Context *Context `protobuf:"bytes,5,opt,name=context,proto3" json:"context,omitempty"`
	// Scope: A map that associates entity types with lists of identifiers. Each entry
	// helps filter requests by specifying which entities are relevant to the operation.
	Scope map[string]*StringArrayValue `protobuf:"bytes,6,rep,name=scope,proto3" json:"scope,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// cursor is an optional parameter used for pagination.
	// It should be the value received in the previous response.
	Cursor        string `protobuf:"bytes,7,opt,name=cursor,proto3" json:"cursor,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionEntityFilterRequest) Reset() {
	*x = PermissionEntityFilterRequest{}
	mi := &file_base_v1_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionEntityFilterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionEntityFilterRequest) ProtoMessage() {}

func (x *PermissionEntityFilterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionEntityFilterRequest.ProtoReflect.Descriptor instead.
func (*PermissionEntityFilterRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{11}
}

func (x *PermissionEntityFilterRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *PermissionEntityFilterRequest) GetMetadata() *PermissionEntityFilterRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *PermissionEntityFilterRequest) GetEntrance() *Entrance {
	if x != nil {
		return x.Entrance
	}
	return nil
}

func (x *PermissionEntityFilterRequest) GetSubject() *Subject {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *PermissionEntityFilterRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PermissionEntityFilterRequest) GetScope() map[string]*StringArrayValue {
	if x != nil {
		return x.Scope
	}
	return nil
}

func (x *PermissionEntityFilterRequest) GetCursor() string {
	if x != nil {
		return x.Cursor
	}
	return ""
}

// PermissionEntityFilterRequestMetadata metadata for the PermissionEntityFilterRequest.
type PermissionEntityFilterRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version of the schema.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	// Token associated with the snap.
	SnapToken string `protobuf:"bytes,2,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	// Depth of lookup, required, must be greater or equal to 3.
	Depth         int32 `protobuf:"varint,3,opt,name=depth,proto3" json:"depth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionEntityFilterRequestMetadata) Reset() {
	*x = PermissionEntityFilterRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionEntityFilterRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionEntityFilterRequestMetadata) ProtoMessage() {}

func (x *PermissionEntityFilterRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionEntityFilterRequestMetadata.ProtoReflect.Descriptor instead.
func (*PermissionEntityFilterRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{12}
}

func (x *PermissionEntityFilterRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

func (x *PermissionEntityFilterRequestMetadata) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

func (x *PermissionEntityFilterRequestMetadata) GetDepth() int32 {
	if x != nil {
		return x.Depth
	}
	return 0
}

// PermissionLookupSubjectRequest is the request message for the LookupSubject method in the Permission service.
type PermissionLookupSubjectRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// Metadata associated with this request, required.
	Metadata *PermissionLookupSubjectRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Entity for which to check the permission, required.
	Entity *Entity `protobuf:"bytes,3,opt,name=entity,proto3" json:"entity,omitempty"`
	// Permission to be checked, can be a permission or relation. Required, and must match the pattern "^([a-zA-Z][a-zA-Z0-9_]{1,62}[a-zA-Z0-9])$", max 64 bytes.
	Permission string `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
	// Reference to the subject to lookup.
	SubjectReference *RelationReference `protobuf:"bytes,5,opt,name=subject_reference,proto3" json:"subject_reference,omitempty"`
	// Context associated with this request.
	Context *Context `protobuf:"bytes,6,opt,name=context,proto3" json:"context,omitempty"`
	// Additional arguments associated with this request.
	Arguments []*Argument `protobuf:"bytes,7,rep,name=arguments,proto3" json:"arguments,omitempty"`
	// page_size is the number of subjects to be returned in the response.
	// The value should be between 1 and 100.
	PageSize uint32 `protobuf:"varint,8,opt,name=page_size,proto3" json:"page_size,omitempty"`
	// continuous_token is an optional parameter used for pagination.
	// It should be the value received in the previous response.
	ContinuousToken string `protobuf:"bytes,9,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PermissionLookupSubjectRequest) Reset() {
	*x = PermissionLookupSubjectRequest{}
	mi := &file_base_v1_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionLookupSubjectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionLookupSubjectRequest) ProtoMessage() {}

func (x *PermissionLookupSubjectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionLookupSubjectRequest.ProtoReflect.Descriptor instead.
func (*PermissionLookupSubjectRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{13}
}

func (x *PermissionLookupSubjectRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *PermissionLookupSubjectRequest) GetMetadata() *PermissionLookupSubjectRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *PermissionLookupSubjectRequest) GetEntity() *Entity {
	if x != nil {
		return x.Entity
	}
	return nil
}

func (x *PermissionLookupSubjectRequest) GetPermission() string {
	if x != nil {
		return x.Permission
	}
	return ""
}

func (x *PermissionLookupSubjectRequest) GetSubjectReference() *RelationReference {
	if x != nil {
		return x.SubjectReference
	}
	return nil
}

func (x *PermissionLookupSubjectRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PermissionLookupSubjectRequest) GetArguments() []*Argument {
	if x != nil {
		return x.Arguments
	}
	return nil
}

func (x *PermissionLookupSubjectRequest) GetPageSize() uint32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *PermissionLookupSubjectRequest) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// PermissionLookupSubjectRequestMetadata metadata for the PermissionLookupSubjectRequest.
type PermissionLookupSubjectRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version of the schema.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	// Token associated with the snap.
	SnapToken string `protobuf:"bytes,2,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	// Depth of the check, must be greater than or equal to 3.
	Depth         int32 `protobuf:"varint,3,opt,name=depth,proto3" json:"depth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionLookupSubjectRequestMetadata) Reset() {
	*x = PermissionLookupSubjectRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionLookupSubjectRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionLookupSubjectRequestMetadata) ProtoMessage() {}

func (x *PermissionLookupSubjectRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionLookupSubjectRequestMetadata.ProtoReflect.Descriptor instead.
func (*PermissionLookupSubjectRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{14}
}

func (x *PermissionLookupSubjectRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

func (x *PermissionLookupSubjectRequestMetadata) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

func (x *PermissionLookupSubjectRequestMetadata) GetDepth() int32 {
	if x != nil {
		return x.Depth
	}
	return 0
}

// PermissionLookupSubjectResponse is the response message for the LookupSubject method in the Permission service.
type PermissionLookupSubjectResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of identifiers for subjects that match the lookup.
	SubjectIds []string `protobuf:"bytes,1,rep,name=subject_ids,proto3" json:"subject_ids,omitempty"`
	// continuous_token is a string that can be used to paginate and retrieve the next set of results.
	ContinuousToken string `protobuf:"bytes,2,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PermissionLookupSubjectResponse) Reset() {
	*x = PermissionLookupSubjectResponse{}
	mi := &file_base_v1_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionLookupSubjectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionLookupSubjectResponse) ProtoMessage() {}

func (x *PermissionLookupSubjectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionLookupSubjectResponse.ProtoReflect.Descriptor instead.
func (*PermissionLookupSubjectResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{15}
}

func (x *PermissionLookupSubjectResponse) GetSubjectIds() []string {
	if x != nil {
		return x.SubjectIds
	}
	return nil
}

func (x *PermissionLookupSubjectResponse) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// PermissionSubjectPermissionRequest is the request message for the SubjectPermission method in the Permission service.
type PermissionSubjectPermissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// Metadata associated with this request, required.
	Metadata *PermissionSubjectPermissionRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Entity for which to check the permission, required.
	Entity *Entity `protobuf:"bytes,3,opt,name=entity,proto3" json:"entity,omitempty"`
	// Subject for which to check the permission, required.
	Subject *Subject `protobuf:"bytes,4,opt,name=subject,proto3" json:"subject,omitempty"`
	// Context associated with this request.
	Context       *Context `protobuf:"bytes,5,opt,name=context,proto3" json:"context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionSubjectPermissionRequest) Reset() {
	*x = PermissionSubjectPermissionRequest{}
	mi := &file_base_v1_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionSubjectPermissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionSubjectPermissionRequest) ProtoMessage() {}

func (x *PermissionSubjectPermissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionSubjectPermissionRequest.ProtoReflect.Descriptor instead.
func (*PermissionSubjectPermissionRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{16}
}

func (x *PermissionSubjectPermissionRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *PermissionSubjectPermissionRequest) GetMetadata() *PermissionSubjectPermissionRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *PermissionSubjectPermissionRequest) GetEntity() *Entity {
	if x != nil {
		return x.Entity
	}
	return nil
}

func (x *PermissionSubjectPermissionRequest) GetSubject() *Subject {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *PermissionSubjectPermissionRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

// PermissionSubjectPermissionRequestMetadata metadata for the PermissionSubjectPermissionRequest.
type PermissionSubjectPermissionRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version of the schema.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	// Token associated with the snap.
	SnapToken string `protobuf:"bytes,2,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	// Whether to only check permissions.
	OnlyPermission bool `protobuf:"varint,3,opt,name=only_permission,proto3" json:"only_permission,omitempty"`
	// Depth of the check, must be greater than or equal to 3.
	Depth         int32 `protobuf:"varint,4,opt,name=depth,proto3" json:"depth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionSubjectPermissionRequestMetadata) Reset() {
	*x = PermissionSubjectPermissionRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionSubjectPermissionRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionSubjectPermissionRequestMetadata) ProtoMessage() {}

func (x *PermissionSubjectPermissionRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionSubjectPermissionRequestMetadata.ProtoReflect.Descriptor instead.
func (*PermissionSubjectPermissionRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{17}
}

func (x *PermissionSubjectPermissionRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

func (x *PermissionSubjectPermissionRequestMetadata) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

func (x *PermissionSubjectPermissionRequestMetadata) GetOnlyPermission() bool {
	if x != nil {
		return x.OnlyPermission
	}
	return false
}

func (x *PermissionSubjectPermissionRequestMetadata) GetDepth() int32 {
	if x != nil {
		return x.Depth
	}
	return 0
}

// PermissionSubjectPermissionResponse is the response message for the SubjectPermission method in the Permission service.
type PermissionSubjectPermissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Map of results for each permission check.
	Results       map[string]CheckResult `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value,enum=base.v1.CheckResult"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionSubjectPermissionResponse) Reset() {
	*x = PermissionSubjectPermissionResponse{}
	mi := &file_base_v1_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionSubjectPermissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionSubjectPermissionResponse) ProtoMessage() {}

func (x *PermissionSubjectPermissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionSubjectPermissionResponse.ProtoReflect.Descriptor instead.
func (*PermissionSubjectPermissionResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{18}
}

func (x *PermissionSubjectPermissionResponse) GetResults() map[string]CheckResult {
	if x != nil {
		return x.Results
	}
	return nil
}

// WatchRequest is the request message for the Watch RPC. It contains the
// details needed to establish a watch stream.
type WatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// Snap token to be used for watching.
	SnapToken     string `protobuf:"bytes,2,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WatchRequest) Reset() {
	*x = WatchRequest{}
	mi := &file_base_v1_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WatchRequest) ProtoMessage() {}

func (x *WatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WatchRequest.ProtoReflect.Descriptor instead.
func (*WatchRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{19}
}

func (x *WatchRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *WatchRequest) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

// WatchResponse is the response message for the Watch RPC. It contains the
// changes in the data that are being watched.
type WatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Changes in the data.
	Changes       *DataChanges `protobuf:"bytes,1,opt,name=changes,proto3" json:"changes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WatchResponse) Reset() {
	*x = WatchResponse{}
	mi := &file_base_v1_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WatchResponse) ProtoMessage() {}

func (x *WatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WatchResponse.ProtoReflect.Descriptor instead.
func (*WatchResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{20}
}

func (x *WatchResponse) GetChanges() *DataChanges {
	if x != nil {
		return x.Changes
	}
	return nil
}

// SchemaWriteRequest is the request message for the Write method in the Schema service.
// It contains tenant_id and the schema to be written.
type SchemaWriteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
	// be a maximum of 64 bytes, and must not be empty.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// schema is the string representation of the schema to be written.
	Schema        string `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaWriteRequest) Reset() {
	*x = SchemaWriteRequest{}
	mi := &file_base_v1_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaWriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaWriteRequest) ProtoMessage() {}

func (x *SchemaWriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaWriteRequest.ProtoReflect.Descriptor instead.
func (*SchemaWriteRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{21}
}

func (x *SchemaWriteRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *SchemaWriteRequest) GetSchema() string {
	if x != nil {
		return x.Schema
	}
	return ""
}

// SchemaWriteResponse is the response message for the Write method in the Schema service.
// It returns the version of the written schema.
type SchemaWriteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// schema_version is the string that identifies the version of the written schema.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaWriteResponse) Reset() {
	*x = SchemaWriteResponse{}
	mi := &file_base_v1_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaWriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaWriteResponse) ProtoMessage() {}

func (x *SchemaWriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaWriteResponse.ProtoReflect.Descriptor instead.
func (*SchemaWriteResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{22}
}

func (x *SchemaWriteResponse) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

// It contains the tenant_id to identify the tenant and metadata of the schema to be edited,
// with the corresponding edits to various entities
type SchemaPartialWriteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
	// be a maximum of 64 bytes, and must not be empty.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// metadata is the additional information needed for the Partial Write request.
	Metadata *SchemaPartialWriteRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Map of entity name with the values needed to be updated
	Partials      map[string]*Partials `protobuf:"bytes,3,rep,name=partials,proto3" json:"partials,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaPartialWriteRequest) Reset() {
	*x = SchemaPartialWriteRequest{}
	mi := &file_base_v1_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaPartialWriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaPartialWriteRequest) ProtoMessage() {}

func (x *SchemaPartialWriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaPartialWriteRequest.ProtoReflect.Descriptor instead.
func (*SchemaPartialWriteRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{23}
}

func (x *SchemaPartialWriteRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *SchemaPartialWriteRequest) GetMetadata() *SchemaPartialWriteRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *SchemaPartialWriteRequest) GetPartials() map[string]*Partials {
	if x != nil {
		return x.Partials
	}
	return nil
}

// SchemaPartialWriteRequestMetadata provides additional information for the Schema Partial Write request.
// It contains schema_version to specify which version of the schema should be read.
type SchemaPartialWriteRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// schema_version is the string that identifies the version of the schema to be read.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaPartialWriteRequestMetadata) Reset() {
	*x = SchemaPartialWriteRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaPartialWriteRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaPartialWriteRequestMetadata) ProtoMessage() {}

func (x *SchemaPartialWriteRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaPartialWriteRequestMetadata.ProtoReflect.Descriptor instead.
func (*SchemaPartialWriteRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{24}
}

func (x *SchemaPartialWriteRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

// SchemaPartialWriteResponse is the response message for the Parietal Write method in the Schema service.
// It returns the requested schema.
type SchemaPartialWriteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// schema_version is the string that identifies the version of the written schema.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaPartialWriteResponse) Reset() {
	*x = SchemaPartialWriteResponse{}
	mi := &file_base_v1_service_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaPartialWriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaPartialWriteResponse) ProtoMessage() {}

func (x *SchemaPartialWriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaPartialWriteResponse.ProtoReflect.Descriptor instead.
func (*SchemaPartialWriteResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{25}
}

func (x *SchemaPartialWriteResponse) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

// SchemaReadRequest is the request message for the Read method in the Schema service.
// It contains tenant_id and metadata about the schema to be read.
type SchemaReadRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
	// be a maximum of 64 bytes, and must not be empty.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// metadata is the additional information needed for the Read request.
	Metadata      *SchemaReadRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaReadRequest) Reset() {
	*x = SchemaReadRequest{}
	mi := &file_base_v1_service_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaReadRequest) ProtoMessage() {}

func (x *SchemaReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaReadRequest.ProtoReflect.Descriptor instead.
func (*SchemaReadRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{26}
}

func (x *SchemaReadRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *SchemaReadRequest) GetMetadata() *SchemaReadRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// SchemaReadRequestMetadata provides additional information for the Schema Read request.
// It contains schema_version to specify which version of the schema should be read.
type SchemaReadRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// schema_version is the string that identifies the version of the schema to be read.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaReadRequestMetadata) Reset() {
	*x = SchemaReadRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaReadRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaReadRequestMetadata) ProtoMessage() {}

func (x *SchemaReadRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaReadRequestMetadata.ProtoReflect.Descriptor instead.
func (*SchemaReadRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{27}
}

func (x *SchemaReadRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

// SchemaReadResponse is the response message for the Read method in the Schema service.
// It returns the requested schema.
type SchemaReadResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// schema is the SchemaDefinition that represents the read schema.
	Schema        *SchemaDefinition `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaReadResponse) Reset() {
	*x = SchemaReadResponse{}
	mi := &file_base_v1_service_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaReadResponse) ProtoMessage() {}

func (x *SchemaReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaReadResponse.ProtoReflect.Descriptor instead.
func (*SchemaReadResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{28}
}

func (x *SchemaReadResponse) GetSchema() *SchemaDefinition {
	if x != nil {
		return x.Schema
	}
	return nil
}

// SchemaListRequest is the request message for the List method in the Schema service.
// It contains tenant_id for which the schemas are to be listed.
type SchemaListRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
	// be a maximum of 64 bytes, and must not be empty.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// page_size is the number of schemas to be returned in the response.
	// The value should be between 1 and 100.
	PageSize uint32 `protobuf:"varint,2,opt,name=page_size,proto3" json:"page_size,omitempty"`
	// continuous_token is an optional parameter used for pagination.
	// It should be the value received in the previous response.
	ContinuousToken string `protobuf:"bytes,3,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SchemaListRequest) Reset() {
	*x = SchemaListRequest{}
	mi := &file_base_v1_service_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaListRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaListRequest) ProtoMessage() {}

func (x *SchemaListRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaListRequest.ProtoReflect.Descriptor instead.
func (*SchemaListRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{29}
}

func (x *SchemaListRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *SchemaListRequest) GetPageSize() uint32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *SchemaListRequest) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// SchemaListResponse is the response message for the List method in the Schema service.
// It returns a paginated list of schemas
type SchemaListResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// head of the schemas is the latest version available for the tenant
	Head string `protobuf:"bytes,1,opt,name=head,proto3" json:"head,omitempty"`
	// list of schema versions with creation timestamps
	Schemas []*SchemaList `protobuf:"bytes,2,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// continuous_token is a string that can be used to paginate and retrieve the next set of results.
	ContinuousToken string `protobuf:"bytes,3,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SchemaListResponse) Reset() {
	*x = SchemaListResponse{}
	mi := &file_base_v1_service_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaListResponse) ProtoMessage() {}

func (x *SchemaListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaListResponse.ProtoReflect.Descriptor instead.
func (*SchemaListResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{30}
}

func (x *SchemaListResponse) GetHead() string {
	if x != nil {
		return x.Head
	}
	return ""
}

func (x *SchemaListResponse) GetSchemas() []*SchemaList {
	if x != nil {
		return x.Schemas
	}
	return nil
}

func (x *SchemaListResponse) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// SchemaList provides a list of schema versions with their corresponding creation timestamps
type SchemaList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	CreatedAt     string                 `protobuf:"bytes,2,opt,name=created_at,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaList) Reset() {
	*x = SchemaList{}
	mi := &file_base_v1_service_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaList) ProtoMessage() {}

func (x *SchemaList) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaList.ProtoReflect.Descriptor instead.
func (*SchemaList) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{31}
}

func (x *SchemaList) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *SchemaList) GetCreatedAt() string {
	if x != nil {
		return x.CreatedAt
	}
	return ""
}

// DataWriteRequest defines the structure of a request for writing data.
// It contains the necessary information such as tenant_id, metadata,
// tuples and attributes for the write operation.
type DataWriteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant_id represents the unique identifier of the tenant for which data is written.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// metadata holds additional data related to the request.
	Metadata *DataWriteRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// tuples contains the list of tuples (entity-relation-entity triples) that need to be written.
	Tuples []*Tuple `protobuf:"bytes,3,rep,name=tuples,proto3" json:"tuples,omitempty"`
	// attributes contains the list of attributes (entity-attribute-value triples) that need to be written.
	Attributes    []*Attribute `protobuf:"bytes,4,rep,name=attributes,proto3" json:"attributes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataWriteRequest) Reset() {
	*x = DataWriteRequest{}
	mi := &file_base_v1_service_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataWriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataWriteRequest) ProtoMessage() {}

func (x *DataWriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataWriteRequest.ProtoReflect.Descriptor instead.
func (*DataWriteRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{32}
}

func (x *DataWriteRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *DataWriteRequest) GetMetadata() *DataWriteRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *DataWriteRequest) GetTuples() []*Tuple {
	if x != nil {
		return x.Tuples
	}
	return nil
}

func (x *DataWriteRequest) GetAttributes() []*Attribute {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// DataWriteRequestMetadata defines the structure of metadata for a write request.
// It includes the schema version of the data to be written.
type DataWriteRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// schema_version represents the version of the schema for the data being written.
	SchemaVersion string `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataWriteRequestMetadata) Reset() {
	*x = DataWriteRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataWriteRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataWriteRequestMetadata) ProtoMessage() {}

func (x *DataWriteRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataWriteRequestMetadata.ProtoReflect.Descriptor instead.
func (*DataWriteRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{33}
}

func (x *DataWriteRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

// DataWriteResponse defines the structure of the response after writing data.
// It contains the snap_token generated after the write operation.
type DataWriteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// snap_token is the token generated after the data write operation, representing a snapshot of the data.
	SnapToken     string `protobuf:"bytes,1,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataWriteResponse) Reset() {
	*x = DataWriteResponse{}
	mi := &file_base_v1_service_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataWriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataWriteResponse) ProtoMessage() {}

func (x *DataWriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataWriteResponse.ProtoReflect.Descriptor instead.
func (*DataWriteResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{34}
}

func (x *DataWriteResponse) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

// Represents a request to write relationship data.
type RelationshipWriteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for the tenant with specific constraints.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// Metadata for the request. It's required.
	Metadata *RelationshipWriteRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// List of tuples for the request. Must have between 1 and 100 items.
	Tuples        []*Tuple `protobuf:"bytes,3,rep,name=tuples,proto3" json:"tuples,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelationshipWriteRequest) Reset() {
	*x = RelationshipWriteRequest{}
	mi := &file_base_v1_service_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationshipWriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationshipWriteRequest) ProtoMessage() {}

func (x *RelationshipWriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationshipWriteRequest.ProtoReflect.Descriptor instead.
func (*RelationshipWriteRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{35}
}

func (x *RelationshipWriteRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *RelationshipWriteRequest) GetMetadata() *RelationshipWriteRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *RelationshipWriteRequest) GetTuples() []*Tuple {
	if x != nil {
		return x.Tuples
	}
	return nil
}

// RelationshipWriteRequestMetadata
type RelationshipWriteRequestMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SchemaVersion string                 `protobuf:"bytes,1,opt,name=schema_version,proto3" json:"schema_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelationshipWriteRequestMetadata) Reset() {
	*x = RelationshipWriteRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationshipWriteRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationshipWriteRequestMetadata) ProtoMessage() {}

func (x *RelationshipWriteRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationshipWriteRequestMetadata.ProtoReflect.Descriptor instead.
func (*RelationshipWriteRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{36}
}

func (x *RelationshipWriteRequestMetadata) GetSchemaVersion() string {
	if x != nil {
		return x.SchemaVersion
	}
	return ""
}

// RelationshipWriteResponse
type RelationshipWriteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SnapToken     string                 `protobuf:"bytes,1,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelationshipWriteResponse) Reset() {
	*x = RelationshipWriteResponse{}
	mi := &file_base_v1_service_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationshipWriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationshipWriteResponse) ProtoMessage() {}

func (x *RelationshipWriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationshipWriteResponse.ProtoReflect.Descriptor instead.
func (*RelationshipWriteResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{37}
}

func (x *RelationshipWriteResponse) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

// RelationshipReadRequest defines the structure of a request for reading relationships.
// It contains the necessary information such as tenant_id, metadata, and filter for the read operation.
type RelationshipReadRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant_id represents the unique identifier of the tenant for which relationships are read.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// metadata holds additional data related to the request.
	Metadata *RelationshipReadRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// filter is used to specify criteria for the data that needs to be read.
	Filter *TupleFilter `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
	// page_size specifies the number of results to return in a single page.
	// If more results are available, a continuous_token is included in the response.
	PageSize uint32 `protobuf:"varint,4,opt,name=page_size,proto3" json:"page_size,omitempty"`
	// continuous_token is used in case of paginated reads to get the next page of results.
	ContinuousToken string `protobuf:"bytes,5,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RelationshipReadRequest) Reset() {
	*x = RelationshipReadRequest{}
	mi := &file_base_v1_service_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationshipReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationshipReadRequest) ProtoMessage() {}

func (x *RelationshipReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationshipReadRequest.ProtoReflect.Descriptor instead.
func (*RelationshipReadRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{38}
}

func (x *RelationshipReadRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *RelationshipReadRequest) GetMetadata() *RelationshipReadRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *RelationshipReadRequest) GetFilter() *TupleFilter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *RelationshipReadRequest) GetPageSize() uint32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *RelationshipReadRequest) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// RelationshipReadRequestMetadata defines the structure of the metadata for a read request focused on relationships.
// It includes the snap_token associated with a particular state of the database.
type RelationshipReadRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// snap_token represents a specific state or "snapshot" of the database.
	SnapToken     string `protobuf:"bytes,1,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelationshipReadRequestMetadata) Reset() {
	*x = RelationshipReadRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationshipReadRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationshipReadRequestMetadata) ProtoMessage() {}

func (x *RelationshipReadRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationshipReadRequestMetadata.ProtoReflect.Descriptor instead.
func (*RelationshipReadRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{39}
}

func (x *RelationshipReadRequestMetadata) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

// RelationshipReadResponse defines the structure of the response after reading relationships.
// It includes the tuples representing the relationships and a continuous token for handling result pagination.
type RelationshipReadResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tuples is a list of the relationships retrieved in the read operation, represented as entity-relation-entity triples.
	Tuples []*Tuple `protobuf:"bytes,1,rep,name=tuples,proto3" json:"tuples,omitempty"`
	// continuous_token is used in the case of paginated reads to retrieve the next page of results.
	ContinuousToken string `protobuf:"bytes,2,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RelationshipReadResponse) Reset() {
	*x = RelationshipReadResponse{}
	mi := &file_base_v1_service_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationshipReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationshipReadResponse) ProtoMessage() {}

func (x *RelationshipReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationshipReadResponse.ProtoReflect.Descriptor instead.
func (*RelationshipReadResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{40}
}

func (x *RelationshipReadResponse) GetTuples() []*Tuple {
	if x != nil {
		return x.Tuples
	}
	return nil
}

func (x *RelationshipReadResponse) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// AttributeReadRequest defines the structure of a request for reading attributes.
// It includes the tenant_id, metadata, attribute filter, page size for pagination, and a continuous token for multi-page results.
type AttributeReadRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant_id represents the unique identifier of the tenant from which the attributes are being read.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// metadata holds additional information related to the request.
	Metadata *AttributeReadRequestMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// filter specifies the criteria used to select the attributes that should be returned.
	Filter *AttributeFilter `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
	// page_size specifies the number of results to return in a single page.
	// If more results are available, a continuous_token is included in the response.
	PageSize uint32 `protobuf:"varint,4,opt,name=page_size,proto3" json:"page_size,omitempty"`
	// continuous_token is used in case of paginated reads to get the next page of results.
	ContinuousToken string `protobuf:"bytes,5,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AttributeReadRequest) Reset() {
	*x = AttributeReadRequest{}
	mi := &file_base_v1_service_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeReadRequest) ProtoMessage() {}

func (x *AttributeReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeReadRequest.ProtoReflect.Descriptor instead.
func (*AttributeReadRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{41}
}

func (x *AttributeReadRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *AttributeReadRequest) GetMetadata() *AttributeReadRequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *AttributeReadRequest) GetFilter() *AttributeFilter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *AttributeReadRequest) GetPageSize() uint32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *AttributeReadRequest) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// AttributeReadRequestMetadata defines the structure for the metadata of an attribute read request.
// It includes the snap_token associated with a particular state of the database.
type AttributeReadRequestMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// snap_token represents a specific state or "snapshot" of the database.
	SnapToken     string `protobuf:"bytes,1,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttributeReadRequestMetadata) Reset() {
	*x = AttributeReadRequestMetadata{}
	mi := &file_base_v1_service_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeReadRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeReadRequestMetadata) ProtoMessage() {}

func (x *AttributeReadRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeReadRequestMetadata.ProtoReflect.Descriptor instead.
func (*AttributeReadRequestMetadata) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{42}
}

func (x *AttributeReadRequestMetadata) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

// AttributeReadResponse defines the structure of the response to an attribute read request.
// It includes the attributes retrieved and a continuous token for handling result pagination.
type AttributeReadResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// attributes is a list of the attributes retrieved in the read operation.
	Attributes []*Attribute `protobuf:"bytes,1,rep,name=attributes,proto3" json:"attributes,omitempty"`
	// continuous_token is used in the case of paginated reads to retrieve the next page of results.
	ContinuousToken string `protobuf:"bytes,2,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AttributeReadResponse) Reset() {
	*x = AttributeReadResponse{}
	mi := &file_base_v1_service_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeReadResponse) ProtoMessage() {}

func (x *AttributeReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeReadResponse.ProtoReflect.Descriptor instead.
func (*AttributeReadResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{43}
}

func (x *AttributeReadResponse) GetAttributes() []*Attribute {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *AttributeReadResponse) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// DataDeleteRequest defines the structure of a request to delete data.
// It includes the tenant_id and filters for selecting tuples and attributes to be deleted.
type DataDeleteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant_id represents the unique identifier of the tenant from which the data will be deleted.
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// tuple_filter specifies the criteria used to select the tuples that should be deleted.
	TupleFilter *TupleFilter `protobuf:"bytes,2,opt,name=tuple_filter,proto3" json:"tuple_filter,omitempty"`
	// attribute_filter specifies the criteria used to select the attributes that should be deleted.
	AttributeFilter *AttributeFilter `protobuf:"bytes,3,opt,name=attribute_filter,proto3" json:"attribute_filter,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DataDeleteRequest) Reset() {
	*x = DataDeleteRequest{}
	mi := &file_base_v1_service_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataDeleteRequest) ProtoMessage() {}

func (x *DataDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataDeleteRequest.ProtoReflect.Descriptor instead.
func (*DataDeleteRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{44}
}

func (x *DataDeleteRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *DataDeleteRequest) GetTupleFilter() *TupleFilter {
	if x != nil {
		return x.TupleFilter
	}
	return nil
}

func (x *DataDeleteRequest) GetAttributeFilter() *AttributeFilter {
	if x != nil {
		return x.AttributeFilter
	}
	return nil
}

// DataDeleteResponse defines the structure of the response to a data delete request.
// It includes a snap_token representing the state of the database after the deletion.
type DataDeleteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// snap_token represents the state of the database after the requested deletions.
	SnapToken     string `protobuf:"bytes,1,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataDeleteResponse) Reset() {
	*x = DataDeleteResponse{}
	mi := &file_base_v1_service_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataDeleteResponse) ProtoMessage() {}

func (x *DataDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataDeleteResponse.ProtoReflect.Descriptor instead.
func (*DataDeleteResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{45}
}

func (x *DataDeleteResponse) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

// RelationshipDeleteRequest
type RelationshipDeleteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TenantId      string                 `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	Filter        *TupleFilter           `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelationshipDeleteRequest) Reset() {
	*x = RelationshipDeleteRequest{}
	mi := &file_base_v1_service_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationshipDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationshipDeleteRequest) ProtoMessage() {}

func (x *RelationshipDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationshipDeleteRequest.ProtoReflect.Descriptor instead.
func (*RelationshipDeleteRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{46}
}

func (x *RelationshipDeleteRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *RelationshipDeleteRequest) GetFilter() *TupleFilter {
	if x != nil {
		return x.Filter
	}
	return nil
}

// RelationshipDeleteResponse
type RelationshipDeleteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SnapToken     string                 `protobuf:"bytes,1,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelationshipDeleteResponse) Reset() {
	*x = RelationshipDeleteResponse{}
	mi := &file_base_v1_service_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationshipDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationshipDeleteResponse) ProtoMessage() {}

func (x *RelationshipDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationshipDeleteResponse.ProtoReflect.Descriptor instead.
func (*RelationshipDeleteResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{47}
}

func (x *RelationshipDeleteResponse) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

// BundleRunRequest is used to request the execution of a bundle.
// It includes tenant_id, the name of the bundle, and additional arguments for execution.
type BundleRunRequest struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	TenantId string                 `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	// Name of the bundle to be executed.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Additional key-value pairs for execution arguments.
	Arguments     map[string]string `protobuf:"bytes,3,rep,name=arguments,proto3" json:"arguments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BundleRunRequest) Reset() {
	*x = BundleRunRequest{}
	mi := &file_base_v1_service_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BundleRunRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BundleRunRequest) ProtoMessage() {}

func (x *BundleRunRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BundleRunRequest.ProtoReflect.Descriptor instead.
func (*BundleRunRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{48}
}

func (x *BundleRunRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *BundleRunRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BundleRunRequest) GetArguments() map[string]string {
	if x != nil {
		return x.Arguments
	}
	return nil
}

// BundleRunResponse is the response for a BundleRunRequest.
// It includes a snap_token, which may be used for tracking the execution or its results.
type BundleRunResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SnapToken     string                 `protobuf:"bytes,1,opt,name=snap_token,proto3" json:"snap_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BundleRunResponse) Reset() {
	*x = BundleRunResponse{}
	mi := &file_base_v1_service_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BundleRunResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BundleRunResponse) ProtoMessage() {}

func (x *BundleRunResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BundleRunResponse.ProtoReflect.Descriptor instead.
func (*BundleRunResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{49}
}

func (x *BundleRunResponse) GetSnapToken() string {
	if x != nil {
		return x.SnapToken
	}
	return ""
}

// BundleWriteRequest is used to request the writing of a bundle.
// It contains the tenant_id to identify the tenant and the Bundles object.
type BundleWriteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TenantId      string                 `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	Bundles       []*DataBundle          `protobuf:"bytes,2,rep,name=bundles,proto3" json:"bundles,omitempty"` // Contains the bundle data to be written.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BundleWriteRequest) Reset() {
	*x = BundleWriteRequest{}
	mi := &file_base_v1_service_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BundleWriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BundleWriteRequest) ProtoMessage() {}

func (x *BundleWriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BundleWriteRequest.ProtoReflect.Descriptor instead.
func (*BundleWriteRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{50}
}

func (x *BundleWriteRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *BundleWriteRequest) GetBundles() []*DataBundle {
	if x != nil {
		return x.Bundles
	}
	return nil
}

// BundleWriteResponse is the response for a BundleWriteRequest.
// It includes a name which could be used as an identifier or acknowledgment.
type BundleWriteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Names         []string               `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"` // Identifier or acknowledgment of the written bundle.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BundleWriteResponse) Reset() {
	*x = BundleWriteResponse{}
	mi := &file_base_v1_service_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BundleWriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BundleWriteResponse) ProtoMessage() {}

func (x *BundleWriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BundleWriteResponse.ProtoReflect.Descriptor instead.
func (*BundleWriteResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{51}
}

func (x *BundleWriteResponse) GetNames() []string {
	if x != nil {
		return x.Names
	}
	return nil
}

type BundleReadRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TenantId      string                 `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BundleReadRequest) Reset() {
	*x = BundleReadRequest{}
	mi := &file_base_v1_service_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BundleReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BundleReadRequest) ProtoMessage() {}

func (x *BundleReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BundleReadRequest.ProtoReflect.Descriptor instead.
func (*BundleReadRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{52}
}

func (x *BundleReadRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *BundleReadRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type BundleReadResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Bundle        *DataBundle            `protobuf:"bytes,1,opt,name=bundle,proto3" json:"bundle,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BundleReadResponse) Reset() {
	*x = BundleReadResponse{}
	mi := &file_base_v1_service_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BundleReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BundleReadResponse) ProtoMessage() {}

func (x *BundleReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BundleReadResponse.ProtoReflect.Descriptor instead.
func (*BundleReadResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{53}
}

func (x *BundleReadResponse) GetBundle() *DataBundle {
	if x != nil {
		return x.Bundle
	}
	return nil
}

// BundleDeleteRequest is used to request the deletion of a bundle.
// It contains the tenant_id to specify the tenant and the name of the bundle to be deleted.
type BundleDeleteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TenantId      string                 `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"` // Name of the bundle to be deleted.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BundleDeleteRequest) Reset() {
	*x = BundleDeleteRequest{}
	mi := &file_base_v1_service_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BundleDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BundleDeleteRequest) ProtoMessage() {}

func (x *BundleDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BundleDeleteRequest.ProtoReflect.Descriptor instead.
func (*BundleDeleteRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{54}
}

func (x *BundleDeleteRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *BundleDeleteRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type BundleDeleteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BundleDeleteResponse) Reset() {
	*x = BundleDeleteResponse{}
	mi := &file_base_v1_service_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BundleDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BundleDeleteResponse) ProtoMessage() {}

func (x *BundleDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BundleDeleteResponse.ProtoReflect.Descriptor instead.
func (*BundleDeleteResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{55}
}

func (x *BundleDeleteResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// TenantCreateRequest is the message used for the request to create a tenant.
type TenantCreateRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is a unique identifier for the tenant.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the name of the tenant.
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TenantCreateRequest) Reset() {
	*x = TenantCreateRequest{}
	mi := &file_base_v1_service_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TenantCreateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TenantCreateRequest) ProtoMessage() {}

func (x *TenantCreateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TenantCreateRequest.ProtoReflect.Descriptor instead.
func (*TenantCreateRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{56}
}

func (x *TenantCreateRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TenantCreateRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// TenantCreateResponse is the message returned from the request to create a tenant.
type TenantCreateResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant is the created tenant information.
	Tenant        *Tenant `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TenantCreateResponse) Reset() {
	*x = TenantCreateResponse{}
	mi := &file_base_v1_service_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TenantCreateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TenantCreateResponse) ProtoMessage() {}

func (x *TenantCreateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TenantCreateResponse.ProtoReflect.Descriptor instead.
func (*TenantCreateResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{57}
}

func (x *TenantCreateResponse) GetTenant() *Tenant {
	if x != nil {
		return x.Tenant
	}
	return nil
}

// TenantDeleteRequest is the message used for the request to delete a tenant.
type TenantDeleteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique identifier of the tenant to be deleted.
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TenantDeleteRequest) Reset() {
	*x = TenantDeleteRequest{}
	mi := &file_base_v1_service_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TenantDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TenantDeleteRequest) ProtoMessage() {}

func (x *TenantDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TenantDeleteRequest.ProtoReflect.Descriptor instead.
func (*TenantDeleteRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{58}
}

func (x *TenantDeleteRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

// TenantDeleteResponse is the message returned from the request to delete a tenant.
type TenantDeleteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenant_id is the tenant id that was deleted.
	TenantId      string `protobuf:"bytes,1,opt,name=tenant_id,proto3" json:"tenant_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TenantDeleteResponse) Reset() {
	*x = TenantDeleteResponse{}
	mi := &file_base_v1_service_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TenantDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TenantDeleteResponse) ProtoMessage() {}

func (x *TenantDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TenantDeleteResponse.ProtoReflect.Descriptor instead.
func (*TenantDeleteResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{59}
}

func (x *TenantDeleteResponse) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

// TenantListRequest is the message used for the request to list all tenants.
type TenantListRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// page_size is the number of tenants to be returned in the response.
	// The value should be between 1 and 100.
	PageSize uint32 `protobuf:"varint,1,opt,name=page_size,proto3" json:"page_size,omitempty"`
	// continuous_token is an optional parameter used for pagination.
	// It should be the value received in the previous response.
	ContinuousToken string `protobuf:"bytes,2,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TenantListRequest) Reset() {
	*x = TenantListRequest{}
	mi := &file_base_v1_service_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TenantListRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TenantListRequest) ProtoMessage() {}

func (x *TenantListRequest) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TenantListRequest.ProtoReflect.Descriptor instead.
func (*TenantListRequest) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{60}
}

func (x *TenantListRequest) GetPageSize() uint32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *TenantListRequest) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

// TenantListResponse is the message returned from the request to list all tenants.
type TenantListResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tenants is a list of tenants.
	Tenants []*Tenant `protobuf:"bytes,1,rep,name=tenants,proto3" json:"tenants,omitempty"`
	// continuous_token is a string that can be used to paginate and retrieve the next set of results.
	ContinuousToken string `protobuf:"bytes,2,opt,name=continuous_token,proto3" json:"continuous_token,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TenantListResponse) Reset() {
	*x = TenantListResponse{}
	mi := &file_base_v1_service_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TenantListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TenantListResponse) ProtoMessage() {}

func (x *TenantListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_base_v1_service_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TenantListResponse.ProtoReflect.Descriptor instead.
func (*TenantListResponse) Descriptor() ([]byte, []int) {
	return file_base_v1_service_proto_rawDescGZIP(), []int{61}
}

func (x *TenantListResponse) GetTenants() []*Tenant {
	if x != nil {
		return x.Tenants
	}
	return nil
}

func (x *TenantListResponse) GetContinuousToken() string {
	if x != nil {
		return x.ContinuousToken
	}
	return ""
}

var File_base_v1_service_proto protoreflect.FileDescriptor

const file_base_v1_service_proto_rawDesc = "" +
	"\n" +
	"\x15base/v1/service.proto\x12\abase.v1\x1a\x12base/v1/base.proto\x1a\x1cgoogle/api/annotations.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\x1a\x17validate/validate.proto\"\x80\a\n" +
	"\x16PermissionCheckRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12M\n" +
	"\bmetadata\x18\x02 \x01(\v2'.base.v1.PermissionCheckRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x12D\n" +
	"\x06entity\x18\x03 \x01(\v2\x0f.base.v1.EntityB\x1b\x92A\x10J\x0e\"repository:1\"\xfaB\x05\x8a\x01\x02\x10\x01R\x06entity\x12v\n" +
	"\n" +
	"permission\x18\x04 \x01(\tBV\x92A624The action the user wants to perform on the resource\xfaB\x1ar\x18(@2\x11^[a-zA-Z_]{1,64}$\xd0\x01\x00R\n" +
	"permission\x124\n" +
	"\asubject\x18\x05 \x01(\v2\x10.base.v1.SubjectB\b\xfaB\x05\x8a\x01\x02\x10\x01R\asubject\x12\xc4\x01\n" +
	"\acontext\x18\x06 \x01(\v2\x10.base.v1.ContextB\x97\x01\x92A\x93\x012\x90\x01Contextual data that can be dynamically added to permission check requests. See details on [Contextual Data](../../operations/contextual-tuples)R\acontext\x12/\n" +
	"\targuments\x18\a \x03(\v2\x11.base.v1.ArgumentR\targuments\"\xb2\x02\n" +
	"\x1ePermissionCheckRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\x12\x89\x01\n" +
	"\n" +
	"snap_token\x18\x02 \x01(\tBi\x92Af2dThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)R\n" +
	"snap_token\x12\\\n" +
	"\x05depth\x18\x03 \x01(\x05BF\x92A<2:Query limit when if recursive database queries got in loop\xfaB\x04\x1a\x02(\x03R\x05depth\"\x87\x01\n" +
	"\x17PermissionCheckResponse\x12&\n" +
	"\x03can\x18\x01 \x01(\x0e2\x14.base.v1.CheckResultR\x03can\x12D\n" +
	"\bmetadata\x18\x02 \x01(\v2(.base.v1.PermissionCheckResponseMetadataR\bmetadata\"C\n" +
	"\x1fPermissionCheckResponseMetadata\x12 \n" +
	"\vcheck_count\x18\x01 \x01(\x05R\vcheck_count\"\xe5\x04\n" +
	"\x17PermissionExpandRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12N\n" +
	"\bmetadata\x18\x02 \x01(\v2(.base.v1.PermissionExpandRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x121\n" +
	"\x06entity\x18\x03 \x01(\v2\x0f.base.v1.EntityB\b\xfaB\x05\x8a\x01\x02\x10\x01R\x06entity\x12=\n" +
	"\n" +
	"permission\x18\x04 \x01(\tB\x1d\xfaB\x1ar\x18(@2\x11^[a-zA-Z_]{1,64}$\xd0\x01\x01R\n" +
	"permission\x12*\n" +
	"\acontext\x18\x05 \x01(\v2\x10.base.v1.ContextR\acontext\x12/\n" +
	"\targuments\x18\x06 \x03(\v2\x11.base.v1.ArgumentR\targuments\"\xd6\x01\n" +
	"\x1fPermissionExpandRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\x12\x8a\x01\n" +
	"\n" +
	"snap_token\x18\x02 \x01(\tBj\x92Ag2eThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens).R\n" +
	"snap_token\"?\n" +
	"\x18PermissionExpandResponse\x12#\n" +
	"\x04tree\x18\x01 \x01(\v2\x0f.base.v1.ExpandR\x04tree\"\x81\a\n" +
	"\x1dPermissionLookupEntityRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12T\n" +
	"\bmetadata\x18\x02 \x01(\v2..base.v1.PermissionLookupEntityRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x12?\n" +
	"\ventity_type\x18\x03 \x01(\tB\x1d\xfaB\x1ar\x18(@2\x11^[a-zA-Z_]{1,64}$\xd0\x01\x00R\ventity_type\x12=\n" +
	"\n" +
	"permission\x18\x04 \x01(\tB\x1d\xfaB\x1ar\x18(@2\x11^[a-zA-Z_]{1,64}$\xd0\x01\x00R\n" +
	"permission\x124\n" +
	"\asubject\x18\x05 \x01(\v2\x10.base.v1.SubjectB\b\xfaB\x05\x8a\x01\x02\x10\x01R\asubject\x12*\n" +
	"\acontext\x18\x06 \x01(\v2\x10.base.v1.ContextR\acontext\x12G\n" +
	"\x05scope\x18\a \x03(\v21.base.v1.PermissionLookupEntityRequest.ScopeEntryR\x05scope\x12'\n" +
	"\tpage_size\x18\b \x01(\rB\t\xfaB\x06*\x04(\x01@\x01R\tpage_size\x124\n" +
	"\x10continuous_token\x18\t \x01(\tB\b\xfaB\x05r\x03\xd0\x01\x01R\x10continuous_token\x1aS\n" +
	"\n" +
	"ScopeEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.base.v1.StringArrayValueR\x05value:\x028\x01\"\xbb\x02\n" +
	"%PermissionLookupEntityRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\x12\x8a\x01\n" +
	"\n" +
	"snap_token\x18\x02 \x01(\tBj\x92Ag2eThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens).R\n" +
	"snap_token\x12]\n" +
	"\x05depth\x18\x03 \x01(\x05BG\x92A=2;Query limit when if recursive database queries got in loop.\xfaB\x04\x1a\x02(\x03R\x05depth\"l\n" +
	"\x1ePermissionLookupEntityResponse\x12\x1e\n" +
	"\n" +
	"entity_ids\x18\x01 \x03(\tR\n" +
	"entity_ids\x12*\n" +
	"\x10continuous_token\x18\x02 \x01(\tR\x10continuous_token\"p\n" +
	"$PermissionLookupEntityStreamResponse\x12\x1c\n" +
	"\tentity_id\x18\x01 \x01(\tR\tentity_id\x12*\n" +
	"\x10continuous_token\x18\x02 \x01(\tR\x10continuous_token\"\xe9\x05\n" +
	"\x1dPermissionEntityFilterRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12T\n" +
	"\bmetadata\x18\x02 \x01(\v2..base.v1.PermissionEntityFilterRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x12-\n" +
	"\bentrance\x18\x03 \x01(\v2\x11.base.v1.EntranceR\bentrance\x12*\n" +
	"\asubject\x18\x04 \x01(\v2\x10.base.v1.SubjectR\asubject\x12*\n" +
	"\acontext\x18\x05 \x01(\v2\x10.base.v1.ContextR\acontext\x12G\n" +
	"\x05scope\x18\x06 \x03(\v21.base.v1.PermissionEntityFilterRequest.ScopeEntryR\x05scope\x12 \n" +
	"\x06cursor\x18\a \x01(\tB\b\xfaB\x05r\x03\xd0\x01\x01R\x06cursor\x1aS\n" +
	"\n" +
	"ScopeEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.base.v1.StringArrayValueR\x05value:\x028\x01\"\xbb\x02\n" +
	"%PermissionEntityFilterRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\x12\x8a\x01\n" +
	"\n" +
	"snap_token\x18\x02 \x01(\tBj\x92Ag2eThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens).R\n" +
	"snap_token\x12]\n" +
	"\x05depth\x18\x03 \x01(\x05BG\x92A=2;Query limit when if recursive database queries got in loop.\xfaB\x04\x1a\x02(\x03R\x05depth\"\xa6\x06\n" +
	"\x1ePermissionLookupSubjectRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12U\n" +
	"\bmetadata\x18\x02 \x01(\v2/.base.v1.PermissionLookupSubjectRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x121\n" +
	"\x06entity\x18\x03 \x01(\v2\x0f.base.v1.EntityB\b\xfaB\x05\x8a\x01\x02\x10\x01R\x06entity\x12=\n" +
	"\n" +
	"permission\x18\x04 \x01(\tB\x1d\xfaB\x1ar\x18(@2\x11^[a-zA-Z_]{1,64}$\xd0\x01\x00R\n" +
	"permission\x12R\n" +
	"\x11subject_reference\x18\x05 \x01(\v2\x1a.base.v1.RelationReferenceB\b\xfaB\x05\x8a\x01\x02\x10\x01R\x11subject_reference\x12*\n" +
	"\acontext\x18\x06 \x01(\v2\x10.base.v1.ContextR\acontext\x12/\n" +
	"\targuments\x18\a \x03(\v2\x11.base.v1.ArgumentR\targuments\x12'\n" +
	"\tpage_size\x18\b \x01(\rB\t\xfaB\x06*\x04(\x01@\x01R\tpage_size\x124\n" +
	"\x10continuous_token\x18\t \x01(\tB\b\xfaB\x05r\x03\xd0\x01\x01R\x10continuous_token\"\xbc\x02\n" +
	"&PermissionLookupSubjectRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\x12\x8a\x01\n" +
	"\n" +
	"snap_token\x18\x02 \x01(\tBj\x92Ag2eThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens).R\n" +
	"snap_token\x12]\n" +
	"\x05depth\x18\x03 \x01(\x05BG\x92A=2;Query limit when if recursive database queries got in loop.\xfaB\x04\x1a\x02(\x03R\x05depth\"o\n" +
	"\x1fPermissionLookupSubjectResponse\x12 \n" +
	"\vsubject_ids\x18\x01 \x03(\tR\vsubject_ids\x12*\n" +
	"\x10continuous_token\x18\x02 \x01(\tR\x10continuous_token\"\xc1\x04\n" +
	"\"PermissionSubjectPermissionRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12Y\n" +
	"\bmetadata\x18\x02 \x01(\v23.base.v1.PermissionSubjectPermissionRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x121\n" +
	"\x06entity\x18\x03 \x01(\v2\x0f.base.v1.EntityB\b\xfaB\x05\x8a\x01\x02\x10\x01R\x06entity\x124\n" +
	"\asubject\x18\x04 \x01(\v2\x10.base.v1.SubjectB\b\xfaB\x05\x8a\x01\x02\x10\x01R\asubject\x12*\n" +
	"\acontext\x18\x05 \x01(\v2\x10.base.v1.ContextR\acontext\"\xea\x02\n" +
	"*PermissionSubjectPermissionRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\x12\x8a\x01\n" +
	"\n" +
	"snap_token\x18\x02 \x01(\tBj\x92Ag2eThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens).R\n" +
	"snap_token\x12(\n" +
	"\x0fonly_permission\x18\x03 \x01(\bR\x0fonly_permission\x12]\n" +
	"\x05depth\x18\x04 \x01(\x05BG\x92A=2;Query limit when if recursive database queries got in loop.\xfaB\x04\x1a\x02(\x03R\x05depth\"\xcc\x01\n" +
	"#PermissionSubjectPermissionResponse\x12S\n" +
	"\aresults\x18\x01 \x03(\v29.base.v1.PermissionSubjectPermissionResponse.ResultsEntryR\aresults\x1aP\n" +
	"\fResultsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12*\n" +
	"\x05value\x18\x02 \x01(\x0e2\x14.base.v1.CheckResultR\x05value:\x028\x01\"\xc8\x03\n" +
	"\fWatchRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12\x8a\x01\n" +
	"\n" +
	"snap_token\x18\x02 \x01(\tBj\x92Ag2eThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens).R\n" +
	"snap_token\"?\n" +
	"\rWatchResponse\x12.\n" +
	"\achanges\x18\x01 \x01(\v2\x14.base.v1.DataChangesR\achanges\"\xd9\x02\n" +
	"\x12SchemaWriteRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12\x16\n" +
	"\x06schema\x18\x02 \x01(\tR\x06schema\"=\n" +
	"\x13SchemaWriteResponse\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\"\xd9\x02\n" +
	"\x19SchemaPartialWriteRequest\x12L\n" +
	"\ttenant_id\x18\x01 \x01(\tB.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12P\n" +
	"\bmetadata\x18\x02 \x01(\v2*.base.v1.SchemaPartialWriteRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x12L\n" +
	"\bpartials\x18\x03 \x03(\v20.base.v1.SchemaPartialWriteRequest.PartialsEntryR\bpartials\x1aN\n" +
	"\rPartialsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12'\n" +
	"\x05value\x18\x02 \x01(\v2\x11.base.v1.PartialsR\x05value:\x028\x01\"K\n" +
	"!SchemaPartialWriteRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\"D\n" +
	"\x1aSchemaPartialWriteResponse\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\"\x8a\x03\n" +
	"\x11SchemaReadRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12H\n" +
	"\bmetadata\x18\x02 \x01(\v2\".base.v1.SchemaReadRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\"C\n" +
	"\x19SchemaReadRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\"G\n" +
	"\x12SchemaReadResponse\x121\n" +
	"\x06schema\x18\x01 \x01(\v2\x19.base.v1.SchemaDefinitionR\x06schema\"\x9f\x03\n" +
	"\x11SchemaListRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12'\n" +
	"\tpage_size\x18\x02 \x01(\rB\t\xfaB\x06*\x04(\x01@\x01R\tpage_size\x124\n" +
	"\x10continuous_token\x18\x03 \x01(\tB\b\xfaB\x05r\x03\xd0\x01\x01R\x10continuous_token\"\x83\x01\n" +
	"\x12SchemaListResponse\x12\x12\n" +
	"\x04head\x18\x01 \x01(\tR\x04head\x12-\n" +
	"\aschemas\x18\x02 \x03(\v2\x13.base.v1.SchemaListR\aschemas\x12*\n" +
	"\x10continuous_token\x18\x03 \x01(\tR\x10continuous_token\"F\n" +
	"\n" +
	"SchemaList\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\x12\x1e\n" +
	"\n" +
	"created_at\x18\x02 \x01(\tR\n" +
	"created_at\"\x86\x04\n" +
	"\x10DataWriteRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12G\n" +
	"\bmetadata\x18\x02 \x01(\v2!.base.v1.DataWriteRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x127\n" +
	"\x06tuples\x18\x03 \x03(\v2\x0e.base.v1.TupleB\x0f\xfaB\f\x92\x01\t\b\x00\"\x05\x8a\x01\x02\x10\x01R\x06tuples\x12C\n" +
	"\n" +
	"attributes\x18\x04 \x03(\v2\x12.base.v1.AttributeB\x0f\xfaB\f\x92\x01\t\b\x00\"\x05\x8a\x01\x02\x10\x01R\n" +
	"attributes\"B\n" +
	"\x18DataWriteRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\"\xa0\x01\n" +
	"\x11DataWriteResponse\x12\x8a\x01\n" +
	"\n" +
	"snap_token\x18\x01 \x01(\tBj\x92Ag2eThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens).R\n" +
	"snap_token\"\xd1\x03\n" +
	"\x18RelationshipWriteRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12O\n" +
	"\bmetadata\x18\x02 \x01(\v2).base.v1.RelationshipWriteRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x127\n" +
	"\x06tuples\x18\x03 \x03(\v2\x0e.base.v1.TupleB\x0f\xfaB\f\x92\x01\t\b\x01\"\x05\x8a\x01\x02\x10\x01R\x06tuples\"J\n" +
	" RelationshipWriteRequestMetadata\x12&\n" +
	"\x0eschema_version\x18\x01 \x01(\tR\x0eschema_version\"\xa7\x01\n" +
	"\x19RelationshipWriteResponse\x12\x89\x01\n" +
	"\n" +
	"snap_token\x18\x01 \x01(\tBi\x92Af2dThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)R\n" +
	"snap_token\"\xad\x04\n" +
	"\x17RelationshipReadRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12N\n" +
	"\bmetadata\x18\x02 \x01(\v2(.base.v1.RelationshipReadRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x126\n" +
	"\x06filter\x18\x03 \x01(\v2\x14.base.v1.TupleFilterB\b\xfaB\x05\x8a\x01\x02\x10\x01R\x06filter\x12'\n" +
	"\tpage_size\x18\x04 \x01(\rB\t\xfaB\x06*\x04(\x01@\x01R\tpage_size\x124\n" +
	"\x10continuous_token\x18\x05 \x01(\tB\b\xfaB\x05r\x03\xd0\x01\x01R\x10continuous_token\"\xad\x01\n" +
	"\x1fRelationshipReadRequestMetadata\x12\x89\x01\n" +
	"\n" +
	"snap_token\x18\x01 \x01(\tBi\x92Af2dThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)R\n" +
	"snap_token\"n\n" +
	"\x18RelationshipReadResponse\x12&\n" +
	"\x06tuples\x18\x01 \x03(\v2\x0e.base.v1.TupleR\x06tuples\x12*\n" +
	"\x10continuous_token\x18\x02 \x01(\tR\x10continuous_token\"\xab\x04\n" +
	"\x14AttributeReadRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12K\n" +
	"\bmetadata\x18\x02 \x01(\v2%.base.v1.AttributeReadRequestMetadataB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bmetadata\x12:\n" +
	"\x06filter\x18\x03 \x01(\v2\x18.base.v1.AttributeFilterB\b\xfaB\x05\x8a\x01\x02\x10\x01R\x06filter\x12'\n" +
	"\tpage_size\x18\x04 \x01(\rB\t\xfaB\x06*\x04(\x01@\x01R\tpage_size\x124\n" +
	"\x10continuous_token\x18\x05 \x01(\tB\b\xfaB\x05r\x03\xd0\x01\x01R\x10continuous_token\"\xaa\x01\n" +
	"\x1cAttributeReadRequestMetadata\x12\x89\x01\n" +
	"\n" +
	"snap_token\x18\x01 \x01(\tBi\x92Af2dThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)R\n" +
	"snap_token\"w\n" +
	"\x15AttributeReadResponse\x122\n" +
	"\n" +
	"attributes\x18\x01 \x03(\v2\x12.base.v1.AttributeR\n" +
	"attributes\x12*\n" +
	"\x10continuous_token\x18\x02 \x01(\tR\x10continuous_token\"\xd4\x03\n" +
	"\x11DataDeleteRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12B\n" +
	"\ftuple_filter\x18\x02 \x01(\v2\x14.base.v1.TupleFilterB\b\xfaB\x05\x8a\x01\x02\x10\x01R\ftuple_filter\x12N\n" +
	"\x10attribute_filter\x18\x03 \x01(\v2\x18.base.v1.AttributeFilterB\b\xfaB\x05\x8a\x01\x02\x10\x01R\x10attribute_filter\"\xa0\x01\n" +
	"\x12DataDeleteResponse\x12\x89\x01\n" +
	"\n" +
	"snap_token\x18\x01 \x01(\tBi\x92Af2dThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)R\n" +
	"snap_token\"\xf6\x02\n" +
	"\x19RelationshipDeleteRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12,\n" +
	"\x06filter\x18\x02 \x01(\v2\x14.base.v1.TupleFilterR\x06filter\"\xa8\x01\n" +
	"\x1aRelationshipDeleteResponse\x12\x89\x01\n" +
	"\n" +
	"snap_token\x18\x01 \x01(\tBi\x92Af2dThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)R\n" +
	"snap_token\"\xd9\x03\n" +
	"\x10BundleRunRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12F\n" +
	"\targuments\x18\x03 \x03(\v2(.base.v1.BundleRunRequest.ArgumentsEntryR\targuments\x1a<\n" +
	"\x0eArgumentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9f\x01\n" +
	"\x11BundleRunResponse\x12\x89\x01\n" +
	"\n" +
	"snap_token\x18\x01 \x01(\tBi\x92Af2dThe snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)R\n" +
	"snap_token\"\xf0\x02\n" +
	"\x12BundleWriteRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12-\n" +
	"\abundles\x18\x02 \x03(\v2\x13.base.v1.DataBundleR\abundles\"+\n" +
	"\x13BundleWriteResponse\x12\x14\n" +
	"\x05names\x18\x01 \x03(\tR\x05names\"\xd4\x02\n" +
	"\x11BundleReadRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\"A\n" +
	"\x12BundleReadResponse\x12+\n" +
	"\x06bundle\x18\x01 \x01(\v2\x13.base.v1.DataBundleR\x06bundle\"\xd6\x02\n" +
	"\x13BundleDeleteRequest\x12\xaa\x02\n" +
	"\ttenant_id\x18\x01 \x01(\tB\x8b\x02\x92A\xd9\x012\xd6\x01Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\“[a-zA-Z0-9-,]+\\“, max 64 bytes.\xfaB+r)(\x80\x012!^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$\xd0\x01\x00R\ttenant_id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\"*\n" +
	"\x14BundleDeleteResponse\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\"a\n" +
	"\x13TenantCreateRequest\x12*\n" +
	"\x02id\x18\x01 \x01(\tB\x1a\xfaB\x17r\x15(@2\x0e[a-zA-Z0-9-,]+\xd0\x01\x00R\x02id\x12\x1e\n" +
	"\x04name\x18\x02 \x01(\tB\n" +
	"\xfaB\ar\x05(@\xd0\x01\x00R\x04name\"?\n" +
	"\x14TenantCreateResponse\x12'\n" +
	"\x06tenant\x18\x01 \x01(\v2\x0f.base.v1.TenantR\x06tenant\"/\n" +
	"\x13TenantDeleteRequest\x12\x18\n" +
	"\x02id\x18\x01 \x01(\tB\b\xfaB\x05r\x03\xd0\x01\x00R\x02id\"4\n" +
	"\x14TenantDeleteResponse\x12\x1c\n" +
	"\ttenant_id\x18\x01 \x01(\tR\ttenant_id\"r\n" +
	"\x11TenantListRequest\x12'\n" +
	"\tpage_size\x18\x01 \x01(\rB\t\xfaB\x06*\x04(\x01@\x01R\tpage_size\x124\n" +
	"\x10continuous_token\x18\x02 \x01(\tB\b\xfaB\x05r\x03\xd0\x01\x01R\x10continuous_token\"k\n" +
	"\x12TenantListResponse\x12)\n" +
	"\atenants\x18\x01 \x03(\v2\x0f.base.v1.TenantR\atenants\x12*\n" +
	"\x10continuous_token\x18\x02 \x01(\tR\x10continuous_token2\x93L\n" +
	"\n" +
	"Permission\x12\xe8\r\n" +
	"\x05Check\x12\x1f.base.v1.PermissionCheckRequest\x1a .base.v1.PermissionCheckResponse\"\x9b\r\x92A\xe3\f\n" +
	"\n" +
	"Permission\x12\tcheck api*\x11permissions.checkj\xb6\f\n" +
	"\rx-codeSamples\x12\xa4\f2\xa1\f\n" +
	"\xc0\x04*\xbd\x04\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\x9d\x04\n" +
	"\x06source\x12\x92\x04\x1a\x8f\x04cr, err := client.Permission.Check(context.Background(), &v1.PermissionCheckRequest {\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.PermissionCheckRequestMetadata {\n" +
	"        SnapToken: \"\",\n" +
	"        SchemaVersion: \"\",\n" +
	"        Depth: 20,\n" +
	"    },\n" +
	"    Entity: &v1.Entity {\n" +
	"        Type: \"repository\",\n" +
	"        Id: \"1\",\n" +
	"    },\n" +
	"    Permission: \"edit\",\n" +
	"    Subject: &v1.Subject {\n" +
	"        Type: \"user\",\n" +
	"        Id: \"1\",\n" +
	"    },\n" +
	"})\n" +
	"if cr.Can == v1.PermissionCheckResponse_Result_RESULT_ALLOWED {\n" +
	"    // RESULT_ALLOWED\n" +
	"} else {\n" +
	"    // RESULT_DENIED\n" +
	"}\n" +
	"\x9b\x04*\x98\x04\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xee\x03\n" +
	"\x06source\x12\xe3\x03\x1a\xe0\x03client.permission.check({\n" +
	"    tenantId: \"t1\", \n" +
	"    metadata: {\n" +
	"        snapToken: \"\",\n" +
	"        schemaVersion: \"\",\n" +
	"        depth: 20\n" +
	"    },\n" +
	"    entity: {\n" +
	"        type: \"repository\",\n" +
	"        id: \"1\"\n" +
	"    },\n" +
	"    permission: \"edit\",\n" +
	"    subject: {\n" +
	"        type: \"user\",\n" +
	"        id: \"1\"\n" +
	"    }\n" +
	"}).then((response) => {\n" +
	"    if (response.can === PermissionCheckResponse_Result.RESULT_ALLOWED) {\n" +
	"        console.log(\"RESULT_ALLOWED\")\n" +
	"    } else {\n" +
	"        console.log(\"RESULT_DENIED\")\n" +
	"    }\n" +
	"})\n" +
	"\xbd\x03*\xba\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\x96\x03\n" +
	"\x06source\x12\x8b\x03\x1a\x88\x03curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/check' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"  \"metadata\": {\n" +
	"    \"snap_token\": \"\",\n" +
	"    \"schema_version\": \"\",\n" +
	"    \"depth\": 20\n" +
	"  },\n" +
	"  \"entity\": {\n" +
	"    \"type\": \"repository\",\n" +
	"    \"id\": \"1\"\n" +
	"  },\n" +
	"  \"permission\": \"edit\",\n" +
	"  \"subject\": {\n" +
	"    \"type\": \"user\",\n" +
	"    \"id\": \"1\",\n" +
	"    \"relation\": \"\"\n" +
	"  }\n" +
	"}'\x82\xd3\xe4\x93\x02.:\x01*\")/v1/tenants/{tenant_id}/permissions/check\x12\xb4\t\n" +
	"\x06Expand\x12 .base.v1.PermissionExpandRequest\x1a!.base.v1.PermissionExpandResponse\"\xe4\b\x92A\xab\b\n" +
	"\n" +
	"Permission\x12\n" +
	"expand api*\x12permissions.expandj\xfc\a\n" +
	"\rx-codeSamples\x12\xea\a2\xe7\a\n" +
	"\xee\x02*\xeb\x02\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xcb\x02\n" +
	"\x06source\x12\xc0\x02\x1a\xbd\x02cr, err := client.Permission.Expand(context.Background(), &v1.PermissionExpandRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.PermissionExpandRequestMetadata{\n" +
	"        SnapToken: \"\",\n" +
	"        SchemaVersion: \"\",\n" +
	"    },\n" +
	"    Entity: &v1.Entity{\n" +
	"        Type: \"repository\",\n" +
	"        Id: \"1\",\n" +
	"    },\n" +
	"    Permission: \"push\",\n" +
	"})\n" +
	"\x8d\x02*\x8a\x02\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xe0\x01\n" +
	"\x06source\x12\xd5\x01\x1a\xd2\x01client.permission.expand({\n" +
	"    tenantId: \"t1\",\n" +
	"    metadata: {\n" +
	"        snapToken: \"\",\n" +
	"        schemaVersion: \"\"\n" +
	"    },\n" +
	"    entity: {\n" +
	"        type: \"repository\",\n" +
	"        id: \"1\"\n" +
	"    },\n" +
	"    permission: \"push\",\n" +
	"})\n" +
	"\xe3\x02*\xe0\x02\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xbc\x02\n" +
	"\x06source\x12\xb1\x02\x1a\xae\x02curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/expand' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"  \"metadata\": {\n" +
	"    \"schema_version\": \"\",\n" +
	"    \"snap_token\": \"\"\n" +
	"  },\n" +
	"  \"entity\": {\n" +
	"    \"type\": \"repository\",\n" +
	"    \"id\": \"1\"\n" +
	"  },\n" +
	"  \"permission\": \"push\"\n" +
	"}'\x82\xd3\xe4\x93\x02/:\x01*\"*/v1/tenants/{tenant_id}/permissions/expand\x12\xb2\f\n" +
	"\fLookupEntity\x12&.base.v1.PermissionLookupEntityRequest\x1a'.base.v1.PermissionLookupEntityResponse\"\xd0\v\x92A\x90\v\n" +
	"\n" +
	"Permission\x12\rlookup entity*\x18permissions.lookupEntityj\xd8\n" +
	"\n" +
	"\rx-codeSamples\x12\xc6\n" +
	"2\xc3\n" +
	"\n" +
	"\xd5\x03*\xd2\x03\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xb2\x03\n" +
	"\x06source\x12\xa7\x03\x1a\xa4\x03cr, err := client.Permission.LookupEntity(context.Background(), &v1.PermissionLookupEntityRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.PermissionLookupEntityRequestMetadata{\n" +
	"        SnapToken: \"\",\n" +
	"        SchemaVersion: \"\",\n" +
	"        Depth: 20,\n" +
	"    },\n" +
	"    EntityType: \"document\",\n" +
	"    Permission: \"edit\",\n" +
	"    Subject: &v1.Subject{\n" +
	"        Type: \"user\",\n" +
	"        Id: \"1\",\n" +
	"    }\n" +
	"    PageSize: 20,\n" +
	"    ContinuousToken: \"\",\n" +
	"})\n" +
	"\xa7\x03*\xa4\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xfa\x02\n" +
	"\x06source\x12\xef\x02\x1a\xec\x02client.permission.lookupEntity({\n" +
	"    tenantId: \"t1\",\n" +
	"    metadata: {\n" +
	"        snapToken: \"\",\n" +
	"        schemaVersion: \"\",\n" +
	"        depth: 20\n" +
	"    },\n" +
	"    entity_type: \"document\",\n" +
	"    permission: \"edit\",\n" +
	"    subject: {\n" +
	"        type: \"user\",\n" +
	"        id: \"1\"\n" +
	"    },\n" +
	"    page_size: 20,\n" +
	"    continuous_token: \"\"\n" +
	"}).then((response) => {\n" +
	"    console.log(response.entity_ids)\n" +
	"})\n" +
	"\xbe\x03*\xbb\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\x97\x03\n" +
	"\x06source\x12\x8c\x03\x1a\x89\x03curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/lookup-entity' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"  \"metadata\":{\n" +
	"    \"snap_token\": \"\",\n" +
	"    \"schema_version\": \"\",\n" +
	"    \"depth\": 20\n" +
	"  },\n" +
	"  \"entity_type\": \"document\",\n" +
	"  \"permission\": \"edit\",\n" +
	"  \"subject\": {\n" +
	"    \"type\":\"user\",\n" +
	"    \"id\":\"1\"\n" +
	"  },\n" +
	"  \"page_size\": 20,\n" +
	"  \"continuous_token\": \"\",\n" +
	"}'\x82\xd3\xe4\x93\x026:\x01*\"1/v1/tenants/{tenant_id}/permissions/lookup-entity\x12\xd0\r\n" +
	"\x12LookupEntityStream\x12&.base.v1.PermissionLookupEntityRequest\x1a-.base.v1.PermissionLookupEntityStreamResponse\"\xe0\f\x92A\x99\f\n" +
	"\n" +
	"Permission\x12\x14lookup entity stream*\x1epermissions.lookupEntityStreamj\xd4\v\n" +
	"\rx-codeSamples\x12\xc2\v2\xbf\v\n" +
	"\xc8\x04*\xc5\x04\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xa5\x04\n" +
	"\x06source\x12\x9a\x04\x1a\x97\x04str, err := client.Permission.LookupEntityStream(context.Background(), &v1.PermissionLookupEntityRequest{\n" +
	"    Metadata: &v1.PermissionLookupEntityRequestMetadata{\n" +
	"        SnapToken: \"\",\n" +
	"        SchemaVersion: \"\",\n" +
	"        Depth: 50,\n" +
	"    },\n" +
	"    EntityType: \"document\",\n" +
	"    Permission: \"view\",\n" +
	"    Subject: &v1.Subject{\n" +
	"        Type: \"user\",\n" +
	"        Id: \"1\",\n" +
	"    },\n" +
	"    PageSize: 20,\n" +
	"    ContinuousToken: \"\",\n" +
	"})\n" +
	"\n" +
	"// handle stream response\n" +
	"for {\n" +
	"    res, err := str.Recv()\n" +
	"\n" +
	"    if err == io.EOF {\n" +
	"        break\n" +
	"    }\n" +
	"\n" +
	"    // res.EntityId\n" +
	"}\n" +
	"\xf1\x06*\xee\x06\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xc4\x06\n" +
	"\x06source\x12\xb9\x06\x1a\xb6\x06const permify = require(\"@permify/permify-node\");\n" +
	"const {PermissionLookupEntityStreamResponse} = require(\"@permify/permify-node/dist/src/grpc/generated/base/v1/service\");\n" +
	"\n" +
	"function main() {\n" +
	"    const client = new permify.grpc.newClient({\n" +
	"        endpoint: \"localhost:3478\",\n" +
	"    });\n" +
	"\n" +
	"    let res = client.permission.lookupEntityStream({\n" +
	"        metadata: {\n" +
	"            snapToken: \"\",\n" +
	"            schemaVersion: \"\",\n" +
	"            depth: 20\n" +
	"        },\n" +
	"        entityType: \"document\",\n" +
	"        permission: \"view\",\n" +
	"        subject: {\n" +
	"            type: \"user\",\n" +
	"            id: \"1\"\n" +
	"        },\n" +
	"        page_size: 20,\n" +
	"        continuous_token: \"\"\n" +
	"    });\n" +
	"\n" +
	"    handle(res);\n" +
	"}\n" +
	"\n" +
	"async function handle(res: AsyncIterable<PermissionLookupEntityStreamResponse>) {\n" +
	"    for await (const response of res) {\n" +
	"        // response.entityId\n" +
	"    }\n" +
	"}\x82\xd3\xe4\x93\x02=:\x01*\"8/v1/tenants/{tenant_id}/permissions/lookup-entity-stream0\x01\x12\xe3\r\n" +
	"\rLookupSubject\x12'.base.v1.PermissionLookupSubjectRequest\x1a(.base.v1.PermissionLookupSubjectResponse\"\xfe\f\x92A\xbd\f\n" +
	"\n" +
	"Permission\x12\x0elookup-subject*\x19permissions.lookupSubjectj\x83\f\n" +
	"\rx-codeSamples\x12\xf1\v2\xee\v\n" +
	"\x9f\x04*\x9c\x04\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xfc\x03\n" +
	"\x06source\x12\xf1\x03\x1a\xee\x03cr, err := client.Permission.LookupSubject(context.Background(), &v1.PermissionLookupSubjectRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.PermissionLookupSubjectRequestMetadata{\n" +
	"        SnapToken: \"\",\n" +
	"        SchemaVersion: \"\",\n" +
	"        Depth: 20,\n" +
	"    },\n" +
	"    Entity: &v1.Entity{\n" +
	"        Type: \"document\",\n" +
	"        Id: \"1\",\n" +
	"    },\n" +
	"    Permission: \"edit\",\n" +
	"    SubjectReference: &v1.RelationReference{\n" +
	"        Type: \"user\",\n" +
	"        Relation: \"\",\n" +
	"    },\n" +
	"    PageSize: 20,\n" +
	"    ContinuousToken: \"\",\n" +
	"})\n" +
	"\xdc\x03*\xd9\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xaf\x03\n" +
	"\x06source\x12\xa4\x03\x1a\xa1\x03client.permission.lookupSubject({\n" +
	"    tenantId: \"t1\",\n" +
	"    metadata: {\n" +
	"        snapToken: \"\",\n" +
	"        schemaVersion: \"\",\n" +
	"        depth: 20,\n" +
	"    },\n" +
	"    entity: {\n" +
	"        type: \"document\",\n" +
	"        id: \"1\",\n" +
	"    },\n" +
	"    permission: \"edit\",\n" +
	"    subject_reference: {\n" +
	"        type: \"user\",\n" +
	"        relation: \"\"\n" +
	"    },\n" +
	"    page_size: 10,\n" +
	"    continuous_token: \"\"\n" +
	"}).then((response) => {\n" +
	"    console.log(response.subject_ids)\n" +
	"})\n" +
	"\xea\x03*\xe7\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xc3\x03\n" +
	"\x06source\x12\xb8\x03\x1a\xb5\x03curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/lookup-subject' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"  \"metadata\":{\n" +
	"    \"snap_token\": \"\",\n" +
	"    \"schema_version\": \"\",\n" +
	"    \"depth\": 20,\n" +
	"  },\n" +
	"  \"entity\": {\n" +
	"    \"type\": \"document\",\n" +
	"    \"id\": \"1\"\n" +
	"  },\n" +
	"  \"permission\": \"edit\",\n" +
	"  \"subject_reference\": {\n" +
	"    \"type\": \"user\",\n" +
	"    \"relation\": \"\"\n" +
	"  },\n" +
	"   page_size: 20,\n" +
	"   continuous_token: \"\"\n" +
	"}'\x82\xd3\xe4\x93\x027:\x01*\"2/v1/tenants/{tenant_id}/permissions/lookup-subject\x12\xf4\f\n" +
	"\x11SubjectPermission\x12+.base.v1.PermissionSubjectPermissionRequest\x1a,.base.v1.PermissionSubjectPermissionResponse\"\x83\f\x92A\xbe\v\n" +
	"\n" +
	"Permission\x12\x12subject permission*\x1dpermissions.subjectPermissionj\xfc\n" +
	"\n" +
	"\rx-codeSamples\x12\xea\n" +
	"2\xe7\n" +
	"\n" +
	"\xf1\x03*\xee\x03\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xce\x03\n" +
	"\x06source\x12\xc3\x03\x1a\xc0\x03cr, err := client.Permission.SubjectPermission(context.Background(), &v1.PermissionSubjectPermissionRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.PermissionSubjectPermissionRequestMetadata{\n" +
	"        SnapToken: \"\",\n" +
	"        SchemaVersion: \"\",\n" +
	"        OnlyPermission: false,\n" +
	"        Depth: 20,\n" +
	"    },\n" +
	"    Entity: &v1.Entity{\n" +
	"        Type: \"repository\",\n" +
	"        Id: \"1\",\n" +
	"    },\n" +
	"    Subject: &v1.Subject{\n" +
	"        Type: \"user\",\n" +
	"        Id: \"1\",\n" +
	"    },\n" +
	"})\n" +
	"\x9f\x03*\x9c\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xf2\x02\n" +
	"\x06source\x12\xe7\x02\x1a\xe4\x02client.permission.subjectPermission({\n" +
	"    tenantId: \"t1\",\n" +
	"    metadata: {\n" +
	"        snapToken: \"\",\n" +
	"        schemaVersion: \"\",\n" +
	"        onlyPermission: true,\n" +
	"        depth: 20\n" +
	"    },\n" +
	"    entity: {\n" +
	"        type: \"repository\",\n" +
	"        id: \"1\"\n" +
	"    },\n" +
	"    subject: {\n" +
	"        type: \"user\",\n" +
	"        id: \"1\"\n" +
	"    }\n" +
	"}).then((response) => {\n" +
	"    console.log(response);\n" +
	"})\n" +
	"\xce\x03*\xcb\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xa7\x03\n" +
	"\x06source\x12\x9c\x03\x1a\x99\x03curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/subject-permission' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"  \"metadata\":{\n" +
	"    \"snap_token\": \"\",\n" +
	"    \"schema_version\": \"\",\n" +
	"    \"only_permission\": true,\n" +
	"    \"depth\": 20\n" +
	"  },\n" +
	"  \"entity\": {\n" +
	"    \"type\": \"repository\",\n" +
	"    \"id\": \"1\"\n" +
	"  },\n" +
	"  \"subject\": {\n" +
	"    \"type\": \"user\",\n" +
	"    \"id\": \"1\",\n" +
	"    \"relation\": \"\"\n" +
	"  }\n" +
	"}'\x82\xd3\xe4\x93\x02;:\x01*\"6/v1/tenants/{tenant_id}/permissions/subject-permission2\x84\b\n" +
	"\x05Watch\x12\xfa\a\n" +
	"\x05Watch\x12\x15.base.v1.WatchRequest\x1a\x16.base.v1.WatchResponse\"\xbf\a\x92A\x93\a\n" +
	"\x05Watch\x12\rwatch changes*\vwatch.watchj\xed\x06\n" +
	"\rx-codeSamples\x12\xdb\x062\xd8\x06\n" +
	"\x9e\x02*\x9b\x02\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xfb\x01\n" +
	"\x06source\x12\xf0\x01\x1a\xed\x01cr, err := client.Watch.Watch(context.Background(), &v1.WatchRequest{\n" +
	"    TenantId:  \"t1\",\n" +
	"    SnapToken: \"\",\n" +
	"})\n" +
	"// handle stream response\n" +
	"for {\n" +
	"    res, err := cr.Recv()\n" +
	"\n" +
	"    if err == io.EOF {\n" +
	"        break\n" +
	"    }\n" +
	"\n" +
	"    // res.Changes\n" +
	"}\n" +
	"\n" +
	"\xb4\x04*\xb1\x04\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\x87\x04\n" +
	"\x06source\x12\xfc\x03\x1a\xf9\x03const permify = require(\"@permify/permify-node\");\n" +
	"const {WatchResponse} = require(\"@permify/permify-node/dist/src/grpc/generated/base/v1/service\");\n" +
	"\n" +
	"function main() {\n" +
	"    const client = new permify.grpc.newClient({\n" +
	"        endpoint: \"localhost:3478\",\n" +
	"    });\n" +
	"\n" +
	"    let res = client.watch.watch({\n" +
	"        tenantId: \"t1\",\n" +
	"        snapToken: \"\"\n" +
	"    });\n" +
	"\n" +
	"    handle(res);\n" +
	"}\n" +
	"\n" +
	"async function handle(res: AsyncIterable<WatchResponse>) {\n" +
	"    for await (const response of res) {\n" +
	"        // response.changes\n" +
	"    }\n" +
	"}\n" +
	"\x82\xd3\xe4\x93\x02\":\x01*\"\x1d/v1/tenants/{tenant_id}/watch0\x012\xac\x1f\n" +
	"\x06Schema\x12\xd3\x10\n" +
	"\x05Write\x12\x1b.base.v1.SchemaWriteRequest\x1a\x1c.base.v1.SchemaWriteResponse\"\x8e\x10\x92A\xda\x0f\n" +
	"\x06Schema\x12\fwrite schema*\rschemas.writej\xb2\x0f\n" +
	"\rx-codeSamples\x12\xa0\x0f2\x9d\x0f\n" +
	"\xf2\x04*\xef\x04\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xcf\x04\n" +
	"\x06source\x12\xc4\x04\x1a\xc1\x04sr, err := client.Schema.Write(context.Background(), &v1.SchemaWriteRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Schema: `\n" +
	"    entity user {}\n" +
	"\n" +
	"    entity organization {\n" +
	"        relation admin @user\n" +
	"        relation member @user\n" +
	"\n" +
	"        action create_repository = (admin or member)\n" +
	"        action delete = admin\n" +
	"    }\n" +
	"\n" +
	"    entity repository {\n" +
	"        relation owner @user\n" +
	"        relation parent @organization\n" +
	"\n" +
	"        action push = owner\n" +
	"        action read = (owner and (parent.admin and parent.member))\n" +
	"        action delete = (parent.member and (parent.admin or owner))\n" +
	"    }\n" +
	"    `,\n" +
	"})\n" +
	"\xf3\x04*\xf0\x04\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xc6\x04\n" +
	"\x06source\x12\xbb\x04\x1a\xb8\x04client.schema.write({\n" +
	"    tenantId: \"t1\",\n" +
	"    schema: `\n" +
	"    entity user {}\n" +
	"\n" +
	"    entity organization {\n" +
	"        relation admin @user\n" +
	"        relation member @user\n" +
	"\n" +
	"        action create_repository = (admin or member)\n" +
	"        action delete = admin\n" +
	"    }\n" +
	"\n" +
	"    entity repository {\n" +
	"        relation owner @user\n" +
	"        relation parent @organization\n" +
	"\n" +
	"        action push = owner\n" +
	"        action read = (owner and (parent.admin and parent.member))\n" +
	"        action delete = (parent.member and (parent.admin or owner))\n" +
	"    }\n" +
	"    `\n" +
	"}).then((response) => {\n" +
	"    // handle response\n" +
	"})\n" +
	"\xaf\x05*\xac\x05\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\x88\x05\n" +
	"\x06source\x12\xfd\x04\x1a\xfa\x04curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/schemas/write' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"schema\": \"entity user {}\\n\\n    entity organization {\\n\\n        relation admin @user\\n        relation member @user\\n\\n        action create_repository = (admin or member)\\n        action delete = admin\\n    }\\n\\n    entity repository {\\n\\n        relation owner @user\\n        relation parent @organization\\n\\n        action push = owner\\n        action read = (owner and (parent.admin and parent.member))\\n        action delete = (parent.member and (parent.admin or owner))\\n }\"\n" +
	"}'\x82\xd3\xe4\x93\x02*:\x01*\"%/v1/tenants/{tenant_id}/schemas/write\x12\xdf\x01\n" +
	"\fPartialWrite\x12\".base.v1.SchemaPartialWriteRequest\x1a#.base.v1.SchemaPartialWriteResponse\"\x85\x01\x92AJ\n" +
	"\x06Schema\x12)partially update your authorization model*\x15schemas.partial-write\x82\xd3\xe4\x93\x022:\x01*2-/v1/tenants/{tenant_id}/schemas/partial-write\x12\xf4\x06\n" +
	"\x04Read\x12\x1a.base.v1.SchemaReadRequest\x1a\x1b.base.v1.SchemaReadResponse\"\xb2\x06\x92A\xff\x05\n" +
	"\x06Schema\x12\vread schema*\fschemas.readj\xd9\x05\n" +
	"\rx-codeSamples\x12\xc7\x052\xc4\x05\n" +
	"\xf5\x01*\xf2\x01\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xd2\x01\n" +
	"\x06source\x12\xc7\x01\x1a\xc4\x01sr, err := client.Schema.Read(context.Background(), &v1.SchemaReadRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.SchemaReadRequestMetadata{\n" +
	"        SchemaVersion: \"cnbe6se5fmal18gpc66g\",\n" +
	"    },\n" +
	"})\n" +
	"\xb6\x01*\xb3\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\x89\x01\n" +
	"\x06source\x12\x7f\x1a}let res = client.schema.read({\n" +
	"    tenantId: \"t1\",\n" +
	"    metadata: {\n" +
	"        schemaVersion: swResponse.schemaVersion,\n" +
	"    },\n" +
	"})\n" +
	"\x90\x02*\x8d\x02\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xe9\x01\n" +
	"\x06source\x12\xde\x01\x1a\xdb\x01curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/schemas/read' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"metadata\": {\n" +
	"        \"schema_version\": \"cnbe6se5fmal18gpc66g\"\n" +
	"    }\n" +
	"}'\x82\xd3\xe4\x93\x02):\x01*\"$/v1/tenants/{tenant_id}/schemas/read\x12\xf2\x05\n" +
	"\x04List\x12\x1a.base.v1.SchemaListRequest\x1a\x1b.base.v1.SchemaListResponse\"\xb0\x05\x92A\xfd\x04\n" +
	"\x06Schema\x12\vlist schema*\fschemas.listj\xd7\x04\n" +
	"\rx-codeSamples\x12\xc5\x042\xc2\x04\n" +
	"\xbd\x01*\xba\x01\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\x9a\x01\n" +
	"\x06source\x12\x8f\x01\x1a\x8c\x01sr, err := client.Schema.List(context.Background(), &v1.SchemaListRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    PageSize: 20,\n" +
	"    ContinuousToken: \"\",\n" +
	"})\n" +
	"\x85\x01*\x82\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"Y\n" +
	"\x06source\x12O\x1aMlet res = client.schema.list({\n" +
	"    tenantId: \"t1\",\n" +
	"    continuousToken: \"\"\n" +
	"})\n" +
	"\xf7\x01*\xf4\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xd0\x01\n" +
	"\x06source\x12\xc5\x01\x1a\xc2\x01curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/schemas/list' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"page_size\": 20,\n" +
	"    \"continuous_token\": \"\"\n" +
	"}'\x82\xd3\xe4\x93\x02):\x01*\"$/v1/tenants/{tenant_id}/schemas/list2\xe5D\n" +
	"\x04Data\x12\xb6\x15\n" +
	"\x05Write\x12\x19.base.v1.DataWriteRequest\x1a\x1a.base.v1.DataWriteResponse\"\xf5\x14\x92A\xc4\x14\n" +
	"\x04Data\x12\n" +
	"write data*\n" +
	"data.writej\xa3\x14\n" +
	"\rx-codeSamples\x12\x91\x142\x8e\x14\n" +
	"\xb6\a*\xb3\a\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\x93\a\n" +
	"\x06source\x12\x88\a\x1a\x85\a// Convert the wrapped attribute value into Any proto message\n" +
	"value, err := anypb.New(&v1.BooleanValue{\n" +
	"    Data: true,\n" +
	"})\n" +
	"if err != nil {\n" +
	"    // Handle error\n" +
	"}\n" +
	"\n" +
	"cr, err := client.Data.Write(context.Background(), &v1.DataWriteRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.DataWriteRequestMetadata{\n" +
	"        SchemaVersion: \"\",\n" +
	"    },\n" +
	"    Tuples: []*v1.Tuple{\n" +
	"        {\n" +
	"            Entity: &v1.Entity{\n" +
	"                Type: \"document\",\n" +
	"                Id:   \"1\",\n" +
	"            },\n" +
	"            Relation: \"editor\",\n" +
	"            Subject:  &v1.Subject{\n" +
	"                Type: \"user\",\n" +
	"                Id:   \"1\",\n" +
	"                Relation: \"\",\n" +
	"            },\n" +
	"        },\n" +
	"    },\n" +
	"    Attributes: []*v1.Attribute{\n" +
	"        {\n" +
	"            Entity: &v1.Entity{\n" +
	"                Type: \"document\",\n" +
	"                Id:   \"1\",\n" +
	"            },\n" +
	"            Attribute: \"is_private\",\n" +
	"            Value:     value,\n" +
	"        },\n" +
	"    },\n" +
	"})\n" +
	"\x80\x06*\xfd\x05\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xd3\x05\n" +
	"\x06source\x12\xc8\x05\x1a\xc5\x05const booleanValue = BooleanValue.fromJSON({ data: true });\n" +
	"\n" +
	"const value = Any.fromJSON({\n" +
	"    typeUrl: 'type.googleapis.com/base.v1.BooleanValue',\n" +
	"    value: BooleanValue.encode(booleanValue).finish()\n" +
	"});\n" +
	"\n" +
	"client.data.write({\n" +
	"    tenantId: \"t1\",\n" +
	"    metadata: {\n" +
	"        schemaVersion: \"\"\n" +
	"    },\n" +
	"    tuples: [{\n" +
	"        entity: {\n" +
	"            type: \"document\",\n" +
	"            id: \"1\"\n" +
	"        },\n" +
	"        relation: \"editor\",\n" +
	"        subject: {\n" +
	"            type: \"user\",\n" +
	"            id: \"1\"\n" +
	"        }\n" +
	"    }],\n" +
	"    attributes: [{\n" +
	"        entity: {\n" +
	"            type: \"document\",\n" +
	"            id: \"1\"\n" +
	"        },\n" +
	"        attribute: \"is_private\",\n" +
	"        value: value,\n" +
	"    }]\n" +
	"}).then((response) => {\n" +
	"    // handle response\n" +
	"})\n" +
	"\xcf\x06*\xcc\x06\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xa8\x06\n" +
	"\x06source\x12\x9d\x06\x1a\x9a\x06curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/write' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"metadata\": {\n" +
	"        \"schema_version\": \"\"\n" +
	"    },\n" +
	"    \"tuples\": [\n" +
	"        {\n" +
	"            \"entity\": {\n" +
	"                \"type\": \"document\",\n" +
	"                \"id\": \"1\"\n" +
	"            },\n" +
	"            \"relation\": \"editor\",\n" +
	"            \"subject\": {\n" +
	"                \"type\": \"user\",\n" +
	"                \"id\": \"1\"\n" +
	"            }\n" +
	"        }\n" +
	"    ],\n" +
	"    \"attributes\": [\n" +
	"        {\n" +
	"            \"entity\": {\n" +
	"                \"type\": \"document\",\n" +
	"                \"id\": \"1\"\n" +
	"            },\n" +
	"            \"attribute\": \"is_private\",\n" +
	"            \"value\": {\n" +
	"                \"@type\": \"type.googleapis.com/base.v1.BooleanValue\",\n" +
	"                \"data\": true\n" +
	"            }\n" +
	"        }\n" +
	"    ]\n" +
	"}'\x82\xd3\xe4\x93\x02':\x01*\"\"/v1/tenants/{tenant_id}/data/write\x12\xc6\x01\n" +
	"\x12WriteRelationships\x12!.base.v1.RelationshipWriteRequest\x1a\".base.v1.RelationshipWriteResponse\"i\x92A0\n" +
	"\x04Data\x12\x13write relationships*\x13relationships.write\x82\xd3\xe4\x93\x020:\x01*\"+/v1/tenants/{tenant_id}/relationships/write\x12\xd1\f\n" +
	"\x11ReadRelationships\x12 .base.v1.RelationshipReadRequest\x1a!.base.v1.RelationshipReadResponse\"\xf6\v\x92A\xb8\v\n" +
	"\x04Data\x12\x12read relationships*\x17data.relationships.readj\x82\v\n" +
	"\rx-codeSamples\x12\xf0\n" +
	"2\xed\n" +
	"\n" +
	"\xa6\x04*\xa3\x04\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\x83\x04\n" +
	"\x06source\x12\xf8\x03\x1a\xf5\x03rr, err := client.Data.ReadRelationships(context.Background(), &v1.Data.RelationshipReadRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.Data.RelationshipReadRequestMetadata{\n" +
	"        SnapToken: \"\"\n" +
	"    },\n" +
	"    Filter: &v1.TupleFilter{\n" +
	"        Entity: &v1.EntityFilter{\n" +
	"            Type: \"organization\",\n" +
	"            Ids: []string{\"1\"},\n" +
	"        },\n" +
	"        Relation: \"member\",\n" +
	"        Subject: &v1.SubjectFilter{\n" +
	"            Type: \"\",\n" +
	"            Id: []string{\"\"},\n" +
	"            Relation: \"\"\n" +
	"        }\n" +
	"    }\n" +
	"})\n" +
	"\x84\x03*\x81\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xd7\x02\n" +
	"\x06source\x12\xcc\x02\x1a\xc9\x02client.data.readRelationships({\n" +
	"  tenantId: \"t1\",\n" +
	"  metadata: {\n" +
	"    snap_token: \"\",\n" +
	"  },\n" +
	"  filter: {\n" +
	"    entity: {\n" +
	"      type: \"organization\",\n" +
	"      ids: [\n" +
	"        \"1\"\n" +
	"      ]\n" +
	"    },\n" +
	"    relation: \"member\",\n" +
	"    subject: {\n" +
	"      type: \"\",\n" +
	"      ids: [],\n" +
	"      relation: \"\"\n" +
	"    }\n" +
	"  }\n" +
	"}).then((response) => {\n" +
	"  // handle response\n" +
	"})\n" +
	"\xba\x03*\xb7\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\x93\x03\n" +
	"\x06source\x12\x88\x03\x1a\x85\x03curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/relationships/read' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"  metadata: {\n" +
	"    snap_token: \"\",\n" +
	"  },\n" +
	"  filter: {\n" +
	"    entity: {\n" +
	"      type: \"organization\",\n" +
	"      ids: [\n" +
	"        \"1\"\n" +
	"      ]\n" +
	"    },\n" +
	"    relation: \"member\",\n" +
	"    subject: {\n" +
	"      type: \"\",\n" +
	"      ids: [],\n" +
	"      relation: \"\"\n" +
	"    }\n" +
	"  }\n" +
	"}'\x82\xd3\xe4\x93\x024:\x01*\"//v1/tenants/{tenant_id}/data/relationships/read\x12\xdc\n" +
	"\n" +
	"\x0eReadAttributes\x12\x1d.base.v1.AttributeReadRequest\x1a\x1e.base.v1.AttributeReadResponse\"\x8a\n" +
	"\x92A\xcf\t\n" +
	"\x04Data\x12\x0fread attributes*\x14data.attributes.readj\x9f\t\n" +
	"\rx-codeSamples\x12\x8d\t2\x8a\t\n" +
	"\xb5\x03*\xb2\x03\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\x92\x03\n" +
	"\x06source\x12\x87\x03\x1a\x84\x03rr, err := client.Data.ReadAttributes(context.Background(), &v1.Data.AttributeReadRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.Data.AttributeReadRequestMetadata{\n" +
	"        SnapToken: \"\",\n" +
	"    },\n" +
	"    Filter: &v1.AttributeFilter{\n" +
	"        Entity: &v1.EntityFilter{\n" +
	"            Type: \"organization\",\n" +
	"            Ids: []string{\"1\"},\n" +
	"        },\n" +
	"        Attributes: []string{\"private\"},\n" +
	"    },\n" +
	"})\n" +
	"\xcb\x02*\xc8\x02\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\x9e\x02\n" +
	"\x06source\x12\x93\x02\x1a\x90\x02client.data.readAttributes({\n" +
	"  tenantId: \"t1\",\n" +
	"  metadata: {\n" +
	"    snap_token: \"\",\n" +
	"  },\n" +
	"  filter: {\n" +
	"    entity: {\n" +
	"      type: \"organization\",\n" +
	"      ids: [\n" +
	"        \"1\"\n" +
	"      ]\n" +
	"    },\n" +
	"    attributes: [\n" +
	"      \"private\"\n" +
	"    ],\n" +
	"  }\n" +
	"}).then((response) => {\n" +
	"  // handle response\n" +
	"})\n" +
	"\x81\x03*\xfe\x02\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xda\x02\n" +
	"\x06source\x12\xcf\x02\x1a\xcc\x02curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/attributes/read' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"  metadata: {\n" +
	"    snap_token: \"\",\n" +
	"  },\n" +
	"  filter: {\n" +
	"    entity: {\n" +
	"      type: \"organization\",\n" +
	"      ids: [\n" +
	"        \"1\"\n" +
	"      ]\n" +
	"    },\n" +
	"    attributes: [\n" +
	"      \"private\"\n" +
	"    ],\n" +
	"  }\n" +
	"}'\x82\xd3\xe4\x93\x021:\x01*\",/v1/tenants/{tenant_id}/data/attributes/read\x12\xa9\f\n" +
	"\x06Delete\x12\x1a.base.v1.DataDeleteRequest\x1a\x1b.base.v1.DataDeleteResponse\"\xe5\v\x92A\xb3\v\n" +
	"\x04Data\x12\vdelete data*\vdata.deletej\x90\v\n" +
	"\rx-codeSamples\x12\xfe\n" +
	"2\xfb\n" +
	"\n" +
	"\x8f\x04*\x8c\x04\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xec\x03\n" +
	"\x06source\x12\xe1\x03\x1a\xde\x03rr, err := client.Data.Delete(context.Background(), &v1.DataDeleteRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Metadata: &v1.DataDeleteRequestMetadata{\n" +
	"        SnapToken: \"\",\n" +
	"    },\n" +
	"    TupleFilter: &v1.TupleFilter{\n" +
	"        Entity: &v1.EntityFilter{\n" +
	"            Type: \"organization\",\n" +
	"            Ids: []string{\"1\"},\n" +
	"        },\n" +
	"        Relation: \"admin\",\n" +
	"        Subject: &v1.SubjectFilter{\n" +
	"            Type: \"user\",\n" +
	"            Id: []string{\"1\"},\n" +
	"            Relation: \"\"\n" +
	"        }\n" +
	"    }\n" +
	"})\n" +
	"\x94\x03*\x91\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xe7\x02\n" +
	"\x06source\x12\xdc\x02\x1a\xd9\x02client.data.delete({\n" +
	"  tenantId: \"t1\",\n" +
	"  metadata: {\n" +
	"    snap_token: \"\",\n" +
	"  },\n" +
	"  tupleFilter: {\n" +
	"    entity: {\n" +
	"      type: \"organization\",\n" +
	"      ids: [\n" +
	"        \"1\"\n" +
	"      ]\n" +
	"    },\n" +
	"    relation: \"admin\",\n" +
	"    subject: {\n" +
	"      type: \"user\",\n" +
	"      ids: [\n" +
	"        \"1\"\n" +
	"      ],\n" +
	"      relation: \"\"\n" +
	"    }\n" +
	"  }\n" +
	"}).then((response) => {\n" +
	"  // handle response\n" +
	"})\n" +
	"\xcf\x03*\xcc\x03\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xa8\x03\n" +
	"\x06source\x12\x9d\x03\x1a\x9a\x03curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/delete' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"  \"tuple_filter\": {\n" +
	"    \"entity\": {\n" +
	"      \"type\": \"organization\",\n" +
	"      \"ids\": [\n" +
	"        \"1\"\n" +
	"      ]\n" +
	"    },\n" +
	"    \"relation\": \"admin\",\n" +
	"    \"subject\": {\n" +
	"      \"type\": \"user\",\n" +
	"      \"ids\": [\n" +
	"        \"1\"\n" +
	"      ],\n" +
	"      \"relation\": \"\"\n" +
	"    }\n" +
	"  },\n" +
	"  \"attribute_filter\": {}\n" +
	"}'\x82\xd3\xe4\x93\x02(:\x01*\"#/v1/tenants/{tenant_id}/data/delete\x12\xcc\x01\n" +
	"\x13DeleteRelationships\x12\".base.v1.RelationshipDeleteRequest\x1a#.base.v1.RelationshipDeleteResponse\"l\x92A2\n" +
	"\x04Data\x12\x14delete relationships*\x14relationships.delete\x82\xd3\xe4\x93\x021:\x01*\",/v1/tenants/{tenant_id}/relationships/delete\x12\xac\b\n" +
	"\tRunBundle\x12\x19.base.v1.BundleRunRequest\x1a\x1a.base.v1.BundleRunResponse\"\xe7\a\x92A\xb1\a\n" +
	"\x04Data\x12\n" +
	"run bundle*\n" +
	"bundle.runj\x90\a\n" +
	"\rx-codeSamples\x12\xfe\x062\xfb\x06\n" +
	"\xa5\x02*\xa2\x02\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\x82\x02\n" +
	"\x06source\x12\xf7\x01\x1a\xf4\x01rr, err := client.Data.RunBundle(context.Background(), &v1.BundleRunRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Name:     \"organization_created\",\n" +
	"    Arguments: map[string]string{\n" +
	"        \"creatorID\":      \"564\",\n" +
	"        \"organizationID\": \"789\",\n" +
	"    },\n" +
	"})\n" +
	"\x8a\x02*\x87\x02\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xdd\x01\n" +
	"\x06source\x12\xd2\x01\x1a\xcf\x01client.data.runBundle({\n" +
	"    tenantId: \"t1\",\n" +
	"    name: \"organization_created\",\n" +
	"    arguments: {\n" +
	"        creatorID: \"564\",\n" +
	"        organizationID: \"789\",\n" +
	"    }\n" +
	"}).then((response) => {\n" +
	"    // handle response\n" +
	"})\n" +
	"\xc3\x02*\xc0\x02\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\x9c\x02\n" +
	"\x06source\x12\x91\x02\x1a\x8e\x02curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/run-bundle' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"name\": \"organization_created\",\n" +
	"    \"arguments\": {\n" +
	"        \"creatorID\": \"564\",\n" +
	"        \"organizationID\": \"789\"\n" +
	"    }\n" +
	"}'\x82\xd3\xe4\x93\x02,:\x01*\"'/v1/tenants/{tenant_id}/data/run-bundle2\xc0!\n" +
	"\x06Bundle\x12\x80\x15\n" +
	"\x05Write\x12\x1b.base.v1.BundleWriteRequest\x1a\x1c.base.v1.BundleWriteResponse\"\xbb\x14\x92A\x88\x14\n" +
	"\x06Bundle\x12\fwrite bundle*\fbundle.writej\xe1\x13\n" +
	"\rx-codeSamples\x12\xcf\x132\xcc\x13\n" +
	"\xd3\x06*\xd0\x06\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\xb0\x06\n" +
	"\x06source\x12\xa5\x06\x1a\xa2\x06rr, err := client.Bundle.Write(context.Background(), &v1.BundleWriteRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Bundles: []*v1.DataBundle{\n" +
	"        {\n" +
	"            Name: \"organization_created\",\n" +
	"            Arguments: []string{\n" +
	"                \"creatorID\",\n" +
	"                \"organizationID\",\n" +
	"            },\n" +
	"            Operations: []*v1.Operation{\n" +
	"                {\n" +
	"                    RelationshipsWrite: []string{\n" +
	"                        \"organization:{{.organizationID}}#admin@user:{{.creatorID}}\",\n" +
	"                        \"organization:{{.organizationID}}#manager@user:{{.creatorID}}\",\n" +
	"                    },\n" +
	"                    AttributesWrite: []string{\n" +
	"                        \"organization:{{.organizationID}}$public|boolean:false\",\n" +
	"                    },\n" +
	"                },\n" +
	"            },\n" +
	"        },\n" +
	"    },\n" +
	"})\n" +
	"\x9b\x06*\x98\x06\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\xee\x05\n" +
	"\x06source\x12\xe3\x05\x1a\xe0\x05client.bundle.write({\n" +
	"    tenantId: \"t1\",\n" +
	"    bundles: [\n" +
	"        {\n" +
	"            name: \"organization_created\",\n" +
	"            arguments: [\n" +
	"                \"creatorID\",\n" +
	"                \"organizationID\",\n" +
	"            ],\n" +
	"            operations: [\n" +
	"                {\n" +
	"                    relationships_write: [\n" +
	"                        \"organization:{{.organizationID}}#admin@user:{{.creatorID}}\",\n" +
	"                        \"organization:{{.organizationID}}#manager@user:{{.creatorID}}\",\n" +
	"                    ],\n" +
	"                    attributes_write: [\n" +
	"                        \"organization:{{.organizationID}}$public|boolean:false\",\n" +
	"                    ]\n" +
	"                }\n" +
	"            ]\n" +
	"        }\n" +
	"    ]\n" +
	"}).then((response) => {\n" +
	"    // handle response\n" +
	"})\n" +
	"\xd5\x06*\xd2\x06\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xae\x06\n" +
	"\x06source\x12\xa3\x06\x1a\xa0\x06curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/bundle/write' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"bundles\": [\n" +
	"        {\n" +
	"            \"name\": \"organization_created\",\n" +
	"            \"arguments\": [\n" +
	"                \"creatorID\",\n" +
	"                \"organizationID\"\n" +
	"            ],\n" +
	"            \"operations\": [\n" +
	"                {\n" +
	"                    \"relationships_write\": [\n" +
	"                        \"organization:{{.organizationID}}#admin@user:{{.creatorID}}\",\n" +
	"                        \"organization:{{.organizationID}}#manager@user:{{.creatorID}}\"\n" +
	"                    ],\n" +
	"                    \"attributes_write\": [\n" +
	"                        \"organization:{{.organizationID}}$public|boolean:false\"\n" +
	"                    ]\n" +
	"                }\n" +
	"            ]\n" +
	"        }\n" +
	"    ]\n" +
	"}'\x82\xd3\xe4\x93\x02):\x01*\"$/v1/tenants/{tenant_id}/bundle/write\x12\x8d\x06\n" +
	"\x04Read\x12\x1a.base.v1.BundleReadRequest\x1a\x1b.base.v1.BundleReadResponse\"\xcb\x05\x92A\x99\x05\n" +
	"\x06Bundle\x12\vread bundle*\vbundle.readj\xf4\x04\n" +
	"\rx-codeSamples\x12\xe2\x042\xdf\x04\n" +
	"\xb8\x01*\xb5\x01\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\x95\x01\n" +
	"\x06source\x12\x8a\x01\x1a\x87\x01rr, err := client.Bundle.Read(context.Background(), &v1.BundleReadRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Name:     \"organization_created\",\n" +
	"})\n" +
	"\xb5\x01*\xb2\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\x88\x01\n" +
	"\x06source\x12~\x1a|client.bundle.read({\n" +
	"    tenantId: \"t1\",\n" +
	"    name: \"organization_created\",\n" +
	"}).then((response) => {\n" +
	"    // handle response\n" +
	"})\n" +
	"\xe9\x01*\xe6\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xc2\x01\n" +
	"\x06source\x12\xb7\x01\x1a\xb4\x01curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/bundle/read' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"name\": \"organization_created\"\n" +
	"}'\x82\xd3\xe4\x93\x02(:\x01*\"#/v1/tenants/{tenant_id}/bundle/read\x12\xa2\x06\n" +
	"\x06Delete\x12\x1c.base.v1.BundleDeleteRequest\x1a\x1d.base.v1.BundleDeleteResponse\"\xda\x05\x92A\xa6\x05\n" +
	"\x06Bundle\x12\rdelete bundle*\rbundle.deletej\xfd\x04\n" +
	"\rx-codeSamples\x12\xeb\x042\xe8\x04\n" +
	"\xbc\x01*\xb9\x01\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\x99\x01\n" +
	"\x06source\x12\x8e\x01\x1a\x8b\x01rr, err := client.Bundle.Delete(context.Background(), &v1.BundleDeleteRequest{\n" +
	"    TenantId: \"t1\",\n" +
	"    Name:     \"organization_created\",\n" +
	"})\n" +
	"\xb8\x01*\xb5\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"\x8b\x01\n" +
	"\x06source\x12\x80\x01\x1a~client.bundle.delete({\n" +
	"    tenantId: \"t1\",\n" +
	"    name: \"organization_created\",\n" +
	"}).then((response) => {\n" +
	"    // handle response\n" +
	"})\n" +
	"\xeb\x01*\xe8\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xc4\x01\n" +
	"\x06source\x12\xb9\x01\x1a\xb6\x01curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/bundle/delete' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"name\": \"organization_created\"\n" +
	"}'\x82\xd3\xe4\x93\x02*:\x01*\"%/v1/tenants/{tenant_id}/bundle/delete2\xc1\x0f\n" +
	"\aTenancy\x12\xbe\x05\n" +
	"\x06Create\x12\x1c.base.v1.TenantCreateRequest\x1a\x1d.base.v1.TenantCreateResponse\"\xf6\x04\x92A\xd5\x04\n" +
	"\aTenancy\x12\rcreate tenant*\x0etenants.createj\xaa\x04\n" +
	"\rx-codeSamples\x12\x98\x042\x95\x04\n" +
	"\x9b\x01*\x98\x01\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"y\n" +
	"\x06source\x12o\x1amrr, err := client.Tenancy.Create(context.Background(), &v1.TenantCreateRequest{\n" +
	"    Id:   \"\",\n" +
	"    Name: \"\"\n" +
	"})\n" +
	"\x98\x01*\x95\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"l\n" +
	"\x06source\x12b\x1a`client.tenancy.create({\n" +
	"   id: \"\",\n" +
	"   name: \"\"\n" +
	"}).then((response) => {\n" +
	"    // handle response\n" +
	"})\n" +
	"\xd9\x01*\xd6\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xb2\x01\n" +
	"\x06source\x12\xa7\x01\x1a\xa4\x01curl --location --request POST 'http://localhost:3476/v1/tenants/create' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"id\": \"\",\n" +
	"    \"name\": \"\"\n" +
	"}'\x82\xd3\xe4\x93\x02\x17:\x01*\"\x12/v1/tenants/create\x12\xba\x04\n" +
	"\x06Delete\x12\x1c.base.v1.TenantDeleteRequest\x1a\x1d.base.v1.TenantDeleteResponse\"\xf2\x03\x92A\xd6\x03\n" +
	"\aTenancy\x12\rdelete tenant*\x0etenants.deletej\xab\x03\n" +
	"\rx-codeSamples\x12\x99\x032\x96\x03\n" +
	"\x8b\x01*\x88\x01\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"i\n" +
	"\x06source\x12_\x1a]rr, err := client.Tenancy.Delete(context.Background(), &v1.TenantDeleteRequest{\n" +
	"    Id: \"\"\n" +
	"})\n" +
	"\x8c\x01*\x89\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"`\n" +
	"\x06source\x12V\x1aTclient.tenancy.delete({\n" +
	"   id: \"\",\n" +
	"}).then((response) => {\n" +
	"    // handle response\n" +
	"})\n" +
	"w*u\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"R\n" +
	"\x06source\x12H\x1aFcurl --location --request DELETE 'http://localhost:3476/v1/tenants/t1'\x82\xd3\xe4\x93\x02\x12*\x10/v1/tenants/{id}\x12\xb7\x05\n" +
	"\x04List\x12\x1a.base.v1.TenantListRequest\x1a\x1b.base.v1.TenantListResponse\"\xf5\x04\x92A\xd6\x04\n" +
	"\aTenancy\x12\flist tenants*\ftenants.listj\xae\x04\n" +
	"\rx-codeSamples\x12\x9c\x042\x99\x04\n" +
	"\xa8\x01*\xa5\x01\n" +
	"\r\n" +
	"\x05label\x12\x04\x1a\x02go\n" +
	"\f\n" +
	"\x04lang\x12\x04\x1a\x02go\n" +
	"\x85\x01\n" +
	"\x06source\x12{\x1aycr, err := client.Tenancy.List(context.Background(), &v1.TenantListRequest{\n" +
	"    PageSize: 20,\n" +
	"    ContinuousToken: \"\",\n" +
	"})\n" +
	"\x85\x01*\x82\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04node\n" +
	"\x14\n" +
	"\x04lang\x12\f\x1a\n" +
	"javascript\n" +
	"Y\n" +
	"\x06source\x12O\x1aMlet res = client.tenancy.list({\n" +
	"    pageSize: 20,\n" +
	"    continuousToken: \"\",\n" +
	"})\n" +
	"\xe3\x01*\xe0\x01\n" +
	"\x0f\n" +
	"\x05label\x12\x06\x1a\x04cURL\n" +
	"\x0e\n" +
	"\x04lang\x12\x06\x1a\x04curl\n" +
	"\xbc\x01\n" +
	"\x06source\x12\xb1\x01\x1a\xae\x01curl --location --request POST 'localhost:3476/v1/tenants/list' \\\n" +
	"--header 'Content-Type: application/json' \\\n" +
	"--data-raw '{\n" +
	"    \"page_size\": 20,\n" +
	"    \"continuous_token\": \"\"\n" +
	"}'\x82\xd3\xe4\x93\x02\x15:\x01*\"\x10/v1/tenants/listB\x8a\x01\n" +
	"\vcom.base.v1B\fServiceProtoP\x01Z0github.com/Permify/permify/pkg/pb/base/v1;basev1\xa2\x02\x03BXX\xaa\x02\aBase.V1\xca\x02\aBase\\V1\xe2\x02\x13Base\\V1\\GPBMetadata\xea\x02\bBase::V1b\x06proto3"

var (
	file_base_v1_service_proto_rawDescOnce sync.Once
	file_base_v1_service_proto_rawDescData []byte
)

func file_base_v1_service_proto_rawDescGZIP() []byte {
	file_base_v1_service_proto_rawDescOnce.Do(func() {
		file_base_v1_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_base_v1_service_proto_rawDesc), len(file_base_v1_service_proto_rawDesc)))
	})
	return file_base_v1_service_proto_rawDescData
}

var file_base_v1_service_proto_msgTypes = make([]protoimpl.MessageInfo, 67)
var file_base_v1_service_proto_goTypes = []any{
	(*PermissionCheckRequest)(nil),                     // 0: base.v1.PermissionCheckRequest
	(*PermissionCheckRequestMetadata)(nil),             // 1: base.v1.PermissionCheckRequestMetadata
	(*PermissionCheckResponse)(nil),                    // 2: base.v1.PermissionCheckResponse
	(*PermissionCheckResponseMetadata)(nil),            // 3: base.v1.PermissionCheckResponseMetadata
	(*PermissionExpandRequest)(nil),                    // 4: base.v1.PermissionExpandRequest
	(*PermissionExpandRequestMetadata)(nil),            // 5: base.v1.PermissionExpandRequestMetadata
	(*PermissionExpandResponse)(nil),                   // 6: base.v1.PermissionExpandResponse
	(*PermissionLookupEntityRequest)(nil),              // 7: base.v1.PermissionLookupEntityRequest
	(*PermissionLookupEntityRequestMetadata)(nil),      // 8: base.v1.PermissionLookupEntityRequestMetadata
	(*PermissionLookupEntityResponse)(nil),             // 9: base.v1.PermissionLookupEntityResponse
	(*PermissionLookupEntityStreamResponse)(nil),       // 10: base.v1.PermissionLookupEntityStreamResponse
	(*PermissionEntityFilterRequest)(nil),              // 11: base.v1.PermissionEntityFilterRequest
	(*PermissionEntityFilterRequestMetadata)(nil),      // 12: base.v1.PermissionEntityFilterRequestMetadata
	(*PermissionLookupSubjectRequest)(nil),             // 13: base.v1.PermissionLookupSubjectRequest
	(*PermissionLookupSubjectRequestMetadata)(nil),     // 14: base.v1.PermissionLookupSubjectRequestMetadata
	(*PermissionLookupSubjectResponse)(nil),            // 15: base.v1.PermissionLookupSubjectResponse
	(*PermissionSubjectPermissionRequest)(nil),         // 16: base.v1.PermissionSubjectPermissionRequest
	(*PermissionSubjectPermissionRequestMetadata)(nil), // 17: base.v1.PermissionSubjectPermissionRequestMetadata
	(*PermissionSubjectPermissionResponse)(nil),        // 18: base.v1.PermissionSubjectPermissionResponse
	(*WatchRequest)(nil),                               // 19: base.v1.WatchRequest
	(*WatchResponse)(nil),                              // 20: base.v1.WatchResponse
	(*SchemaWriteRequest)(nil),                         // 21: base.v1.SchemaWriteRequest
	(*SchemaWriteResponse)(nil),                        // 22: base.v1.SchemaWriteResponse
	(*SchemaPartialWriteRequest)(nil),                  // 23: base.v1.SchemaPartialWriteRequest
	(*SchemaPartialWriteRequestMetadata)(nil),          // 24: base.v1.SchemaPartialWriteRequestMetadata
	(*SchemaPartialWriteResponse)(nil),                 // 25: base.v1.SchemaPartialWriteResponse
	(*SchemaReadRequest)(nil),                          // 26: base.v1.SchemaReadRequest
	(*SchemaReadRequestMetadata)(nil),                  // 27: base.v1.SchemaReadRequestMetadata
	(*SchemaReadResponse)(nil),                         // 28: base.v1.SchemaReadResponse
	(*SchemaListRequest)(nil),                          // 29: base.v1.SchemaListRequest
	(*SchemaListResponse)(nil),                         // 30: base.v1.SchemaListResponse
	(*SchemaList)(nil),                                 // 31: base.v1.SchemaList
	(*DataWriteRequest)(nil),                           // 32: base.v1.DataWriteRequest
	(*DataWriteRequestMetadata)(nil),                   // 33: base.v1.DataWriteRequestMetadata
	(*DataWriteResponse)(nil),                          // 34: base.v1.DataWriteResponse
	(*RelationshipWriteRequest)(nil),                   // 35: base.v1.RelationshipWriteRequest
	(*RelationshipWriteRequestMetadata)(nil),           // 36: base.v1.RelationshipWriteRequestMetadata
	(*RelationshipWriteResponse)(nil),                  // 37: base.v1.RelationshipWriteResponse
	(*RelationshipReadRequest)(nil),                    // 38: base.v1.RelationshipReadRequest
	(*RelationshipReadRequestMetadata)(nil),            // 39: base.v1.RelationshipReadRequestMetadata
	(*RelationshipReadResponse)(nil),                   // 40: base.v1.RelationshipReadResponse
	(*AttributeReadRequest)(nil),                       // 41: base.v1.AttributeReadRequest
	(*AttributeReadRequestMetadata)(nil),               // 42: base.v1.AttributeReadRequestMetadata
	(*AttributeReadResponse)(nil),                      // 43: base.v1.AttributeReadResponse
	(*DataDeleteRequest)(nil),                          // 44: base.v1.DataDeleteRequest
	(*DataDeleteResponse)(nil),                         // 45: base.v1.DataDeleteResponse
	(*RelationshipDeleteRequest)(nil),                  // 46: base.v1.RelationshipDeleteRequest
	(*RelationshipDeleteResponse)(nil),                 // 47: base.v1.RelationshipDeleteResponse
	(*BundleRunRequest)(nil),                           // 48: base.v1.BundleRunRequest
	(*BundleRunResponse)(nil),                          // 49: base.v1.BundleRunResponse
	(*BundleWriteRequest)(nil),                         // 50: base.v1.BundleWriteRequest
	(*BundleWriteResponse)(nil),                        // 51: base.v1.BundleWriteResponse
	(*BundleReadRequest)(nil),                          // 52: base.v1.BundleReadRequest
	(*BundleReadResponse)(nil),                         // 53: base.v1.BundleReadResponse
	(*BundleDeleteRequest)(nil),                        // 54: base.v1.BundleDeleteRequest
	(*BundleDeleteResponse)(nil),                       // 55: base.v1.BundleDeleteResponse
	(*TenantCreateRequest)(nil),                        // 56: base.v1.TenantCreateRequest
	(*TenantCreateResponse)(nil),                       // 57: base.v1.TenantCreateResponse
	(*TenantDeleteRequest)(nil),                        // 58: base.v1.TenantDeleteRequest
	(*TenantDeleteResponse)(nil),                       // 59: base.v1.TenantDeleteResponse
	(*TenantListRequest)(nil),                          // 60: base.v1.TenantListRequest
	(*TenantListResponse)(nil),                         // 61: base.v1.TenantListResponse
	nil,                                                // 62: base.v1.PermissionLookupEntityRequest.ScopeEntry
	nil,                                                // 63: base.v1.PermissionEntityFilterRequest.ScopeEntry
	nil,                                                // 64: base.v1.PermissionSubjectPermissionResponse.ResultsEntry
	nil,                                                // 65: base.v1.SchemaPartialWriteRequest.PartialsEntry
	nil,                                                // 66: base.v1.BundleRunRequest.ArgumentsEntry
	(*Entity)(nil),                                     // 67: base.v1.Entity
	(*Subject)(nil),                                    // 68: base.v1.Subject
	(*Context)(nil),                                    // 69: base.v1.Context
	(*Argument)(nil),                                   // 70: base.v1.Argument
	(CheckResult)(0),                                   // 71: base.v1.CheckResult
	(*Expand)(nil),                                     // 72: base.v1.Expand
	(*Entrance)(nil),                                   // 73: base.v1.Entrance
	(*RelationReference)(nil),                          // 74: base.v1.RelationReference
	(*DataChanges)(nil),                                // 75: base.v1.DataChanges
	(*SchemaDefinition)(nil),                           // 76: base.v1.SchemaDefinition
	(*Tuple)(nil),                                      // 77: base.v1.Tuple
	(*Attribute)(nil),                                  // 78: base.v1.Attribute
	(*TupleFilter)(nil),                                // 79: base.v1.TupleFilter
	(*AttributeFilter)(nil),                            // 80: base.v1.AttributeFilter
	(*DataBundle)(nil),                                 // 81: base.v1.DataBundle
	(*Tenant)(nil),                                     // 82: base.v1.Tenant
	(*StringArrayValue)(nil),                           // 83: base.v1.StringArrayValue
	(*Partials)(nil),                                   // 84: base.v1.Partials
}
var file_base_v1_service_proto_depIdxs = []int32{
	1,  // 0: base.v1.PermissionCheckRequest.metadata:type_name -> base.v1.PermissionCheckRequestMetadata
	67, // 1: base.v1.PermissionCheckRequest.entity:type_name -> base.v1.Entity
	68, // 2: base.v1.PermissionCheckRequest.subject:type_name -> base.v1.Subject
	69, // 3: base.v1.PermissionCheckRequest.context:type_name -> base.v1.Context
	70, // 4: base.v1.PermissionCheckRequest.arguments:type_name -> base.v1.Argument
	71, // 5: base.v1.PermissionCheckResponse.can:type_name -> base.v1.CheckResult
	3,  // 6: base.v1.PermissionCheckResponse.metadata:type_name -> base.v1.PermissionCheckResponseMetadata
	5,  // 7: base.v1.PermissionExpandRequest.metadata:type_name -> base.v1.PermissionExpandRequestMetadata
	67, // 8: base.v1.PermissionExpandRequest.entity:type_name -> base.v1.Entity
	69, // 9: base.v1.PermissionExpandRequest.context:type_name -> base.v1.Context
	70, // 10: base.v1.PermissionExpandRequest.arguments:type_name -> base.v1.Argument
	72, // 11: base.v1.PermissionExpandResponse.tree:type_name -> base.v1.Expand
	8,  // 12: base.v1.PermissionLookupEntityRequest.metadata:type_name -> base.v1.PermissionLookupEntityRequestMetadata
	68, // 13: base.v1.PermissionLookupEntityRequest.subject:type_name -> base.v1.Subject
	69, // 14: base.v1.PermissionLookupEntityRequest.context:type_name -> base.v1.Context
	62, // 15: base.v1.PermissionLookupEntityRequest.scope:type_name -> base.v1.PermissionLookupEntityRequest.ScopeEntry
	12, // 16: base.v1.PermissionEntityFilterRequest.metadata:type_name -> base.v1.PermissionEntityFilterRequestMetadata
	73, // 17: base.v1.PermissionEntityFilterRequest.entrance:type_name -> base.v1.Entrance
	68, // 18: base.v1.PermissionEntityFilterRequest.subject:type_name -> base.v1.Subject
	69, // 19: base.v1.PermissionEntityFilterRequest.context:type_name -> base.v1.Context
	63, // 20: base.v1.PermissionEntityFilterRequest.scope:type_name -> base.v1.PermissionEntityFilterRequest.ScopeEntry
	14, // 21: base.v1.PermissionLookupSubjectRequest.metadata:type_name -> base.v1.PermissionLookupSubjectRequestMetadata
	67, // 22: base.v1.PermissionLookupSubjectRequest.entity:type_name -> base.v1.Entity
	74, // 23: base.v1.PermissionLookupSubjectRequest.subject_reference:type_name -> base.v1.RelationReference
	69, // 24: base.v1.PermissionLookupSubjectRequest.context:type_name -> base.v1.Context
	70, // 25: base.v1.PermissionLookupSubjectRequest.arguments:type_name -> base.v1.Argument
	17, // 26: base.v1.PermissionSubjectPermissionRequest.metadata:type_name -> base.v1.PermissionSubjectPermissionRequestMetadata
	67, // 27: base.v1.PermissionSubjectPermissionRequest.entity:type_name -> base.v1.Entity
	68, // 28: base.v1.PermissionSubjectPermissionRequest.subject:type_name -> base.v1.Subject
	69, // 29: base.v1.PermissionSubjectPermissionRequest.context:type_name -> base.v1.Context
	64, // 30: base.v1.PermissionSubjectPermissionResponse.results:type_name -> base.v1.PermissionSubjectPermissionResponse.ResultsEntry
	75, // 31: base.v1.WatchResponse.changes:type_name -> base.v1.DataChanges
	24, // 32: base.v1.SchemaPartialWriteRequest.metadata:type_name -> base.v1.SchemaPartialWriteRequestMetadata
	65, // 33: base.v1.SchemaPartialWriteRequest.partials:type_name -> base.v1.SchemaPartialWriteRequest.PartialsEntry
	27, // 34: base.v1.SchemaReadRequest.metadata:type_name -> base.v1.SchemaReadRequestMetadata
	76, // 35: base.v1.SchemaReadResponse.schema:type_name -> base.v1.SchemaDefinition
	31, // 36: base.v1.SchemaListResponse.schemas:type_name -> base.v1.SchemaList
	33, // 37: base.v1.DataWriteRequest.metadata:type_name -> base.v1.DataWriteRequestMetadata
	77, // 38: base.v1.DataWriteRequest.tuples:type_name -> base.v1.Tuple
	78, // 39: base.v1.DataWriteRequest.attributes:type_name -> base.v1.Attribute
	36, // 40: base.v1.RelationshipWriteRequest.metadata:type_name -> base.v1.RelationshipWriteRequestMetadata
	77, // 41: base.v1.RelationshipWriteRequest.tuples:type_name -> base.v1.Tuple
	39, // 42: base.v1.RelationshipReadRequest.metadata:type_name -> base.v1.RelationshipReadRequestMetadata
	79, // 43: base.v1.RelationshipReadRequest.filter:type_name -> base.v1.TupleFilter
	77, // 44: base.v1.RelationshipReadResponse.tuples:type_name -> base.v1.Tuple
	42, // 45: base.v1.AttributeReadRequest.metadata:type_name -> base.v1.AttributeReadRequestMetadata
	80, // 46: base.v1.AttributeReadRequest.filter:type_name -> base.v1.AttributeFilter
	78, // 47: base.v1.AttributeReadResponse.attributes:type_name -> base.v1.Attribute
	79, // 48: base.v1.DataDeleteRequest.tuple_filter:type_name -> base.v1.TupleFilter
	80, // 49: base.v1.DataDeleteRequest.attribute_filter:type_name -> base.v1.AttributeFilter
	79, // 50: base.v1.RelationshipDeleteRequest.filter:type_name -> base.v1.TupleFilter
	66, // 51: base.v1.BundleRunRequest.arguments:type_name -> base.v1.BundleRunRequest.ArgumentsEntry
	81, // 52: base.v1.BundleWriteRequest.bundles:type_name -> base.v1.DataBundle
	81, // 53: base.v1.BundleReadResponse.bundle:type_name -> base.v1.DataBundle
	82, // 54: base.v1.TenantCreateResponse.tenant:type_name -> base.v1.Tenant
	82, // 55: base.v1.TenantListResponse.tenants:type_name -> base.v1.Tenant
	83, // 56: base.v1.PermissionLookupEntityRequest.ScopeEntry.value:type_name -> base.v1.StringArrayValue
	83, // 57: base.v1.PermissionEntityFilterRequest.ScopeEntry.value:type_name -> base.v1.StringArrayValue
	71, // 58: base.v1.PermissionSubjectPermissionResponse.ResultsEntry.value:type_name -> base.v1.CheckResult
	84, // 59: base.v1.SchemaPartialWriteRequest.PartialsEntry.value:type_name -> base.v1.Partials
	0,  // 60: base.v1.Permission.Check:input_type -> base.v1.PermissionCheckRequest
	4,  // 61: base.v1.Permission.Expand:input_type -> base.v1.PermissionExpandRequest
	7,  // 62: base.v1.Permission.LookupEntity:input_type -> base.v1.PermissionLookupEntityRequest
	7,  // 63: base.v1.Permission.LookupEntityStream:input_type -> base.v1.PermissionLookupEntityRequest
	13, // 64: base.v1.Permission.LookupSubject:input_type -> base.v1.PermissionLookupSubjectRequest
	16, // 65: base.v1.Permission.SubjectPermission:input_type -> base.v1.PermissionSubjectPermissionRequest
	19, // 66: base.v1.Watch.Watch:input_type -> base.v1.WatchRequest
	21, // 67: base.v1.Schema.Write:input_type -> base.v1.SchemaWriteRequest
	23, // 68: base.v1.Schema.PartialWrite:input_type -> base.v1.SchemaPartialWriteRequest
	26, // 69: base.v1.Schema.Read:input_type -> base.v1.SchemaReadRequest
	29, // 70: base.v1.Schema.List:input_type -> base.v1.SchemaListRequest
	32, // 71: base.v1.Data.Write:input_type -> base.v1.DataWriteRequest
	35, // 72: base.v1.Data.WriteRelationships:input_type -> base.v1.RelationshipWriteRequest
	38, // 73: base.v1.Data.ReadRelationships:input_type -> base.v1.RelationshipReadRequest
	41, // 74: base.v1.Data.ReadAttributes:input_type -> base.v1.AttributeReadRequest
	44, // 75: base.v1.Data.Delete:input_type -> base.v1.DataDeleteRequest
	46, // 76: base.v1.Data.DeleteRelationships:input_type -> base.v1.RelationshipDeleteRequest
	48, // 77: base.v1.Data.RunBundle:input_type -> base.v1.BundleRunRequest
	50, // 78: base.v1.Bundle.Write:input_type -> base.v1.BundleWriteRequest
	52, // 79: base.v1.Bundle.Read:input_type -> base.v1.BundleReadRequest
	54, // 80: base.v1.Bundle.Delete:input_type -> base.v1.BundleDeleteRequest
	56, // 81: base.v1.Tenancy.Create:input_type -> base.v1.TenantCreateRequest
	58, // 82: base.v1.Tenancy.Delete:input_type -> base.v1.TenantDeleteRequest
	60, // 83: base.v1.Tenancy.List:input_type -> base.v1.TenantListRequest
	2,  // 84: base.v1.Permission.Check:output_type -> base.v1.PermissionCheckResponse
	6,  // 85: base.v1.Permission.Expand:output_type -> base.v1.PermissionExpandResponse
	9,  // 86: base.v1.Permission.LookupEntity:output_type -> base.v1.PermissionLookupEntityResponse
	10, // 87: base.v1.Permission.LookupEntityStream:output_type -> base.v1.PermissionLookupEntityStreamResponse
	15, // 88: base.v1.Permission.LookupSubject:output_type -> base.v1.PermissionLookupSubjectResponse
	18, // 89: base.v1.Permission.SubjectPermission:output_type -> base.v1.PermissionSubjectPermissionResponse
	20, // 90: base.v1.Watch.Watch:output_type -> base.v1.WatchResponse
	22, // 91: base.v1.Schema.Write:output_type -> base.v1.SchemaWriteResponse
	25, // 92: base.v1.Schema.PartialWrite:output_type -> base.v1.SchemaPartialWriteResponse
	28, // 93: base.v1.Schema.Read:output_type -> base.v1.SchemaReadResponse
	30, // 94: base.v1.Schema.List:output_type -> base.v1.SchemaListResponse
	34, // 95: base.v1.Data.Write:output_type -> base.v1.DataWriteResponse
	37, // 96: base.v1.Data.WriteRelationships:output_type -> base.v1.RelationshipWriteResponse
	40, // 97: base.v1.Data.ReadRelationships:output_type -> base.v1.RelationshipReadResponse
	43, // 98: base.v1.Data.ReadAttributes:output_type -> base.v1.AttributeReadResponse
	45, // 99: base.v1.Data.Delete:output_type -> base.v1.DataDeleteResponse
	47, // 100: base.v1.Data.DeleteRelationships:output_type -> base.v1.RelationshipDeleteResponse
	49, // 101: base.v1.Data.RunBundle:output_type -> base.v1.BundleRunResponse
	51, // 102: base.v1.Bundle.Write:output_type -> base.v1.BundleWriteResponse
	53, // 103: base.v1.Bundle.Read:output_type -> base.v1.BundleReadResponse
	55, // 104: base.v1.Bundle.Delete:output_type -> base.v1.BundleDeleteResponse
	57, // 105: base.v1.Tenancy.Create:output_type -> base.v1.TenantCreateResponse
	59, // 106: base.v1.Tenancy.Delete:output_type -> base.v1.TenantDeleteResponse
	61, // 107: base.v1.Tenancy.List:output_type -> base.v1.TenantListResponse
	84, // [84:108] is the sub-list for method output_type
	60, // [60:84] is the sub-list for method input_type
	60, // [60:60] is the sub-list for extension type_name
	60, // [60:60] is the sub-list for extension extendee
	0,  // [0:60] is the sub-list for field type_name
}

func init() { file_base_v1_service_proto_init() }
func file_base_v1_service_proto_init() {
	if File_base_v1_service_proto != nil {
		return
	}
	file_base_v1_base_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_base_v1_service_proto_rawDesc), len(file_base_v1_service_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   67,
			NumExtensions: 0,
			NumServices:   6,
		},
		GoTypes:           file_base_v1_service_proto_goTypes,
		DependencyIndexes: file_base_v1_service_proto_depIdxs,
		MessageInfos:      file_base_v1_service_proto_msgTypes,
	}.Build()
	File_base_v1_service_proto = out.File
	file_base_v1_service_proto_goTypes = nil
	file_base_v1_service_proto_depIdxs = nil
}
